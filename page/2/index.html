<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="Yitee" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Warmchay"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Yitee</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '温暖纯良，爱与自由', '玻璃晴朗，橘子辉煌'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-OOP/四 基础语法 III"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/10/OOP/%E5%9B%9B%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%20III/"
    >OOP 4 -- 基础语法III</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/10/OOP/%E5%9B%9B%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%20III/" class="article-date">
  <time datetime="2021-04-10T13:56:04.455Z" itemprop="datePublished">2021-04-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/OOP/">OOP</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <script src="/assets/js/APlayer.min.js"> </script><h1 id="四-基础语法-III"><a href="#四-基础语法-III" class="headerlink" title="四 基础语法 III"></a>四 基础语法 III</h1><h2 id="4-1-继承"><a href="#4-1-继承" class="headerlink" title="4.1 继承"></a>4.1 继承</h2><ul>
<li>在已有类的基础上，通过“继承”来定义新的类，实现对已有代码的复用</li>
<li>常见继承方式：public， private<ol>
<li><code>class Derived:[private]Base&#123;..&#125;;</code> 缺省继承方式为private继承</li>
<li><code>class Derived:public Base&#123;...&#125;;</code></li>
</ol>
</li>
<li><strong>被继承</strong>的已有类，被称为基类(base class)， 也称为“父类”</li>
<li>通过继承得到的新类，称为派生类（derived class，即“子类”， “扩展类”）</li>
</ul>
<h3 id="4-1-1-派生类对象的构造与析构过程"><a href="#4-1-1-派生类对象的构造与析构过程" class="headerlink" title="4.1.1 派生类对象的构造与析构过程"></a>4.1.1 派生类对象的构造与析构过程</h3><ol>
<li>基类中的数据成员，通过继承称为派生类对象的一部分，需要在构造派生类对象的过程中调用<strong>基类构造函数来正确初始化</strong><ul>
<li>如果没有显式调用，则编译器会自动生成一个对基类的默认构造函数的调用</li>
<li>如果想要显式调用，则只能在<strong>派生类构造函数的初始化成员列表</strong>中进行，既可以<strong>调用基类中不带参数</strong>的默认构造函数，也可以<strong>调用合适的带参数</strong>的其他构造函数</li>
</ul>
</li>
<li>先执行基类的构造函数来初始化继承来的数据，再执行派生类的构造函数</li>
<li>对象析构时，<strong>先执行派生类析构函数</strong>，<strong>再执行</strong>由编译器自动调用的<strong>基类的析构函数</strong></li>
</ol>
<h3 id="4-1-2-继承基类构造函数（1）"><a href="#4-1-2-继承基类构造函数（1）" class="headerlink" title="4.1.2 继承基类构造函数（1）"></a>4.1.2 继承基类构造函数（1）</h3><p>在派生类中使用<code>using Base::Base</code>；来继承基类构造函数，相当于给派生类“定义”了相应参数的构造函数</p>
<p>编译器会根据Base的构造函数给其基类相应的构造函数</p>
<blockquote>
<p>敲了好多次demo，都是错的，我也不知道为啥，这里就没有举例了</p>
</blockquote>
<h3 id="4-1-3-继承基类构造函数（2）"><a href="#4-1-3-继承基类构造函数（2）" class="headerlink" title="4.1.3 继承基类构造函数（2）"></a>4.1.3 继承基类构造函数（2）</h3><ol>
<li>虽然基类构造函数的<strong>参数默认值不会被派生类继承</strong>，但由默认参数导致的多个构造函数版本都会被派生类继承</li>
<li>如果基类的<strong>某个构造函数被声明为私有成员函数</strong>，则<strong>不能</strong>在派生类中声明继承该构造函数</li>
<li>如果派生类使用了继承基类构造函数，编译器就不会再为派生类生成默认构造函数</li>
</ol>
<p><strong>总结：</strong> 即子类会继承基类的默认函数（非私有函数</p>
<p><strong>思考一下：</strong> 根据Derive类的定义，这个语句能通过编译码？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derive d1;</span><br><span class="line">Derive <span class="built_in">array</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<h2 id="4-2-函数重写"><a href="#4-2-函数重写" class="headerlink" title="4.2 函数重写"></a>4.2 函数重写</h2><blockquote>
<p><strong>非重载！！！</strong></p>
</blockquote>
<h3 id="4-2-1-派生类（对象）中的基类成员"><a href="#4-2-1-派生类（对象）中的基类成员" class="headerlink" title="4.2.1 派生类（对象）中的基类成员"></a>4.2.1 派生类（对象）中的基类成员</h3><ol>
<li>派生类对象包含从基类继承来的数据成员，构成了“基类子对象”</li>
<li><strong>基类中的私有成员</strong>，不允许在派生类成员函数中被访问，也不允许派生类的对象访问他们<ul>
<li>真正体现“基类私有”， 对派生类也不开放其权限</li>
</ul>
</li>
<li><strong>基类中的公有成员：</strong> <ul>
<li>使用public继承方式，则成为派生类的公有成员，既可以在派生类成员函数中访问，也可以被派生类的对象访问</li>
<li>使用private继承方式，只能<strong>供派生类成员函数</strong>访问，不能被派生类对象访问</li>
</ul>
</li>
</ol>
<h3 id="4-2-2-派生类重写基类成员函数"><a href="#4-2-2-派生类重写基类成员函数" class="headerlink" title="4.2.2 派生类重写基类成员函数"></a>4.2.2 派生类重写基类成员函数</h3><ol>
<li>基类已定义的成员函数，在派生类中可以重新定义它，这被称为函数<strong>重写（override）</strong></li>
<li>重写发生时，基类中该成员函数的其他重载函数都将被屏蔽掉，不能提供给派生类对象使用</li>
<li>可以在派生类中通过<code>using 类名::成员函数名</code>;在派生类中“恢复”指定的基类成员函数（即去掉屏蔽），使其重新可用</li>
</ol>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210410193818499.png" alt="image-20210410193818499" style="zoom:50%;">

<blockquote>
<p><code>4.9</code>被强制转换为<code>4</code>，依旧没有使用基类</p>
</blockquote>
<p>当在<code>D1</code>中定义使用<code>B::f</code>后即可使用基类<code>B</code>中关于<code>f</code>的重载函数</p>
<h2 id="4-3-虚函数"><a href="#4-3-虚函数" class="headerlink" title="4.3 虚函数"></a>4.3 虚函数</h2><h3 id="4-3-1-向上映射-amp-向下映射"><a href="#4-3-1-向上映射-amp-向下映射" class="headerlink" title="4.3.1 向上映射 &amp; 向下映射"></a>4.3.1 向上映射 &amp; 向下映射</h3><ol>
<li>派生类对象转换成基类对象，为<strong>向上映射</strong>。基类对象转换成派生类对象，称为<strong>向下映射</strong></li>
<li>向上映射（派生类$\rightarrow$基类）可以由编译器自动完成，为隐式的<strong>自动类型转换</strong></li>
<li>凡接受<strong>基类对象</strong>的地方（如函数参数），都可以使用派生类对象，编译器会自动将派生类对象转换为基类对象以便使用</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">overWriteTest</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    overWriteTest()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is father&#x27;s func&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span>:</span><span class="keyword">public</span> overWriteTest</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    child()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        data = <span class="number">1234</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is child&#x27;s func:&quot;</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(overWriteTest tmp)</span></span>&#123;</span><br><span class="line">    tmp.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    child tmp;</span><br><span class="line">    tmp.print();</span><br><span class="line">    func(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* this is child&#x27;s func:1234</span></span><br><span class="line"><span class="comment">* this is father&#x27;s func</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*相当于运行：*/</span></span><br><span class="line">child::print()</span><br><span class="line">father::print()</span><br></pre></td></tr></table></figure>

<h3 id="4-3-2-虚函数"><a href="#4-3-2-虚函数" class="headerlink" title="4.3.2 虚函数"></a>4.3.2 虚函数</h3><blockquote>
<p>类似于<strong>多态</strong></p>
</blockquote>
<p>对于被派生类重写的成员函数，若它在基类中被声明为虚函数，则通过<strong>基类指针或引用</strong>调用该成员函数时，编译器将<strong>根据所指（或引用）对象的实际类型</strong>决定是调用基类中的函数，还是调用派生类重写的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> 返回类型函数名（形式参数）; <span class="comment">//虚函数</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>若某成员函数在基类中声明为<strong>虚函数</strong>，当<strong>派生类重写</strong>它时，无论是否声明为虚函数，该成员函数都仍然是<strong>虚函数</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123;&#125;;<span class="comment">//构造函数不是必要的</span></span><br><span class="line">    <span class="keyword">virtual</span> ~B()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;释放B类内存&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is B!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C()&#123;&#125;</span><br><span class="line">    ~C()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;释放C类内存&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is C!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(B* ptr)</span></span>&#123;</span><br><span class="line">    ptr-&gt;print();</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;B.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B* ptr = <span class="keyword">new</span> C; <span class="comment">// ptr指向C类地址</span></span><br><span class="line">    ptr-&gt;print();</span><br><span class="line">    display(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span> is C!</span><br><span class="line"><span class="keyword">this</span> is C!</span><br><span class="line">释放C类内存</span><br><span class="line">释放B类内存</span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-禁止重写的虚函数"><a href="#4-3-3-禁止重写的虚函数" class="headerlink" title="4.3.3 禁止重写的虚函数"></a>4.3.3 禁止重写的虚函数</h3><ol>
<li>使用<code>final</code>关键字修饰的虚函数，派生类不可对它进行<strong>重写</strong> – 改变函数定义（行为）</li>
<li>在派生过程中，<code>final</code>可以在<strong>继承关系链的“中途”</strong>进行设定，禁止后续派生类对指定虚函数重写</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// 到此为止，后续子类不可重写此接口</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>; <span class="comment">//无法通过编译</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于全是虚函数的基类，可以看成全为接口的类</p>
<h2 id="4-4-自动类型转换"><a href="#4-4-自动类型转换" class="headerlink" title="4.4 自动类型转换"></a>4.4 自动类型转换</h2><p>对于用户自定义的类类型，编译系统需要定义专门的函数来告诉编译系统该如何转换，需要用到：</p>
<ul>
<li>带参数的构造函数（基本数据类型=》自定义数据类型）</li>
<li>转换函数（自定义数据类型=〉基本数据类型）</li>
</ul>
<p>来进行抽象数据类型和基本数据类型之间的转换</p>
<h3 id="4-4-1-自定义类型转换"><a href="#4-4-1-自定义类型转换" class="headerlink" title="4.4.1 自定义类型转换"></a>4.4.1 自定义类型转换</h3><h4 id="lt-1-gt-在源类中定义“目标类型转换运算符”"><a href="#lt-1-gt-在源类中定义“目标类型转换运算符”" class="headerlink" title="&lt;1&gt; 在源类中定义“目标类型转换运算符”"></a>&lt;1&gt; 在源类中定义“目标类型转换运算符”</h4><blockquote>
<p>进行目标类重载</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dst</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Dst()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dst::Dst()&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Src</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Src() &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Src::Src()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">Dst</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Src::operator Dst() called&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> Dst();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="lt-2-gt-在目标类中定义“源类对象作参数的构造函数”"><a href="#lt-2-gt-在目标类中定义“源类对象作参数的构造函数”" class="headerlink" title="&lt;2&gt; 在目标类中定义“源类对象作参数的构造函数”"></a>&lt;2&gt; 在目标类中定义“源类对象作参数的构造函数”</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Src</span>;</span> <span class="comment">//前置类型声明，因为Dst中要用到Src类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dst</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Dst() &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dst::Dst()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">  Dst(<span class="keyword">const</span> Src&amp; s) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dst::Dst(const Src&amp;)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Src</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Src() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Src::Src()&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lt-3-gt-单参数的构造函数「基本数据类型-》自定义数据类型」"><a href="#lt-3-gt-单参数的构造函数「基本数据类型-》自定义数据类型」" class="headerlink" title="&lt;3&gt; 单参数的构造函数「基本数据类型=》自定义数据类型」"></a>&lt;3&gt; 单参数的构造函数「基本数据类型=》自定义数据类型」</h4><ul>
<li>能够将一个标准类型数据转换成类对象，也能够将另一个类的对象转换成构造函数所在的类对象</li>
<li>如果不希望转换构造函数生效，拒绝其他类型通过转换构造函数转换为本类型，可以在转换构造函数前面加上<code>explicit</code></li>
</ul>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Complex():ele1(<span class="number">0.0</span>),imag(<span class="number">0.0</span>)&#123;&#125;;</span><br><span class="line">    Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i):ele1(r),ele2(i)&#123;&#125;;  </span><br><span class="line">    Complex(<span class="keyword">double</span> r) <span class="comment">//  转换构造函数</span></span><br><span class="line">    &#123;  </span><br><span class="line">        ele1=r;  </span><br><span class="line">        ele2=<span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">double</span> ele1;  </span><br><span class="line">    <span class="keyword">double</span> ele2;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c=<span class="number">1.2</span>;<span class="comment">//调用转换构造函数将1.2转换为Complex类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lt-4-gt-类型转换「自定义数据类型-gt-基本数据类型」"><a href="#lt-4-gt-类型转换「自定义数据类型-gt-基本数据类型」" class="headerlink" title="&lt;4&gt; 类型转换「自定义数据类型 -&gt; 基本数据类型」"></a>&lt;4&gt; 类型转换「自定义数据类型 -&gt; 基本数据类型」</h4><p>类型转换函数的一般形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> 类型名()&#123;</span><br><span class="line">	实现转换的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//定义类型转换函数</span></span><br><span class="line">    <span class="keyword">return</span> ele1;</span><br><span class="line">  &#125;</span><br><span class="line">  ...;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值的类型由类型名确定</li>
<li>只能作为成员函数</li>
<li>与运算符重载函数相似，都使用operator开头，只是被重载的是类型名</li>
</ul>
<p>在这里，double类型经过重载后，除了原有的含义外，还有新的含义（将一个Complex类对象转换为double类型数据，并指定了转换方法）。</p>
<p>这样，编译系统不仅能识别原有的<code>double</code>型数据，还会把<code>Complex</code>类对象作为<code>double</code>型数据处理，即程序中的<code>Complex</code>类对象具有双重身份，既是<code>Complex</code>对象，也是<code>double</code>类型数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1.2</span>, <span class="number">2.3</span>)</span></span>;  </span><br><span class="line">    <span class="keyword">double</span> d;  </span><br><span class="line">    d = c1 + <span class="number">1.1</span>; <span class="comment">// 调用类型转换函数将c1转换为double</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="4-5-禁止自动类型转换"><a href="#4-5-禁止自动类型转换" class="headerlink" title="4.5 禁止自动类型转换"></a>4.5 禁止自动类型转换</h2><h3 id="4-5-1-explicit"><a href="#4-5-1-explicit" class="headerlink" title="4.5.1 explicit()"></a>4.5.1 explicit()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Src</span>;</span> <span class="comment">//前置类型声明，因为Dst中要用到Src类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dst</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Dst() &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dst::Dst()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">explicit</span> <span class="comment">//&lt;1&gt; 不准用于自动类型转换</span></span><br><span class="line">  Dst(<span class="keyword">const</span> Src&amp; s) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dst::Dst(const Src&amp;)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Src</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Src() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Src::Src()&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">explicit</span> <span class="comment">//&lt;2&gt; 不准用于自动类型转换</span></span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">Dst</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Src::operator Dst() called&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> Dst();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当操作遇到转换时，此时即视为<strong>自动类型转换</strong></p>
</blockquote>
<h3 id="4-5-2-delete"><a href="#4-5-2-delete" class="headerlink" title="4.5.2 delete"></a>4.5.2 delete</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用=delete修饰的成员函数，不允许被调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  T(<span class="keyword">int</span>) &#123;&#125;</span><br><span class="line">  <span class="comment">/// 若没有下一条语句，则main函数中所有语句均可以编译通过</span></span><br><span class="line">  T(<span class="keyword">char</span>) = <span class="keyword">delete</span>; <span class="comment">// 可以消除自动转换带来的隐患</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(T t)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Fun(<span class="number">1</span>); </span><br><span class="line">  <span class="comment">/// Fun(&#x27;A&#x27;); 自动类型转换失败（char-&gt;int）， 编译不通过</span></span><br><span class="line">  <span class="function">T <span class="title">ci</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>也可以采用delete删除普通函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="keyword">char</span> c)</span> </span>= <span class="keyword">delete</span>;	<span class="comment">///显示删除char版本</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Fun(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">///Fun(&#x27;A&#x27;); ///编译不通过</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>转换构造函数</strong>和类<strong>型构造函数</strong>都有一个共同的功能：当用户自定义后，当需要时编译系统会自动调用</p>
<h2 id="4-6-强制类型转换"><a href="#4-6-强制类型转换" class="headerlink" title="4.6 强制类型转换"></a>4.6 强制类型转换</h2><h3 id="4-6-1-显式转换"><a href="#4-6-1-显式转换" class="headerlink" title="4.6.1 显式转换"></a>4.6.1 显式转换</h3><ul>
<li><p><code>dynamic_cast&lt;Dst_Type&gt;(Src_var)</code></p>
<ul>
<li><code>Src_var</code>必须是<strong>引用或指针类型</strong>，<code>Dst_Type</code>类中含有<strong>虚函数</strong>，否则会有编译错误</li>
</ul>
<p><font color="red"><strong>dynamic只能转指针</strong></font></p>
<ul>
<li>如果<strong>目标类与源类</strong>之间没有<strong>继承</strong>关系，则转换失败，返回空指针</li>
</ul>
</li>
<li><p><code>static_cast&lt;Dst_Type&gt;(Src_var)</code></p>
<ul>
<li><font color="red"><b>基类对象不能转换成派生类对象</b></font>，但是基类<strong>指针</strong>可以转换成派生类<strong>指针</strong></li>
</ul>
<blockquote>
<p>对象不可向下转，指针可以向下转</p>
</blockquote>
<ul>
<li><strong>派生类对象（指针）</strong>可以转换成<strong>基类对象（指针）</strong></li>
<li>没有继承关系的类之间，必须具有转换途径才能进行转换（要么自定义，要么语言语法支持）</li>
</ul>
</li>
</ul>
<h2 id="4-7-函数模板"><a href="#4-7-函数模板" class="headerlink" title="4.7 函数模板"></a>4.7 函数模板</h2><ul>
<li><p>有些算法实现与类型无关，可以将函数的参数类型定义为一种特殊的“参数”，这样就得到了“函数模板”</p>
</li>
<li><p>定义函数模板的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">返回类型 函数名称(函数参数)；</span><br></pre></td></tr></table></figure>
</li>
<li><p>E.g. 任意两个类型的变量相加的“函数模板”：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T a, T b)</span></span>&#123;<span class="keyword">return</span> a+b;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>函数模板在调用时，因为编译器能自动推导出实际参数的类型，所以形式上调用一个函数模版与普通函数没有区别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">3</span>, b=<span class="number">4</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; sum(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似函数重载，但是这里模版只写了一次，而重载写了许多次，简化了很多。</p>
<ul>
<li><strong>函数模板参数也可以赋默认值，如</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> To=<span class="keyword">float</span>, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2=<span class="keyword">float</span>, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4&gt;</span><br><span class="line">To func(T1 v1, T2 v2, T3 v3, T4 v4)&#123;...&#125;</span><br><span class="line">...</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">func(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&quot;cde&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="4-8-类模板"><a href="#4-8-类模板" class="headerlink" title="4.8 类模板"></a>4.8 类模板</h2><h3 id="lt-1-gt-模板1"><a href="#lt-1-gt-模板1" class="headerlink" title="&lt;1&gt; 模板1"></a>&lt;1&gt; 模板1</h3><p>在定义类时也可以讲一些类型信息抽取出来，用模板参数来替换，从而使类更具有通用性，这种类被称为“类模板”。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">  T data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//类模板成员函数的定义方式一：在类模板中定义</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义方式二：在类模板外定义</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">A::print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br></pre></td></tr></table></figure>

<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210414213734167.png" alt="image-20210414213734167" style="zoom:50%;">

<ul>
<li>依次实例化的过程</li>
</ul>
<h3 id="lt-2-gt-模板2"><a href="#lt-2-gt-模板2" class="headerlink" title="&lt;2&gt; 模板2"></a>&lt;2&gt; 模板2</h3><p><strong>类模板的“模板参数”</strong></p>
<ol>
<li><p><strong>类型参数</strong>：使用<code>typename</code>或<code>class</code>标记</p>
</li>
<li><p><strong>非类型参数</strong>：<strong>整数，</strong> 枚举，指针（指向对象或函数），引用（引用对象或引用函数）。其中，整数类型是比较常用的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">unsigned</span> size&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">array</span>&#123;</span></span><br><span class="line">  T elems[size];</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">char</span>, 10&gt; array0;<span class="comment">//用类模板实例定义对象</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="lt-3-gt-模板3"><a href="#lt-3-gt-模板3" class="headerlink" title="&lt;3&gt; 模板3"></a>&lt;3&gt; 模板3</h3><p><strong>模板参数是另一个类模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TTo, <span class="keyword">typename</span> TT1&gt; <span class="class"><span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">  A&lt;T, T&gt; bar;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>比较复杂的类模板，用bar来实例化</li>
</ul>
<h2 id="4-9-成员函数模板"><a href="#4-9-成员函数模板" class="headerlink" title="4.9 成员函数模板"></a>4.9 成员函数模板</h2><h3 id="lt-1-gt-模板1-1"><a href="#lt-1-gt-模板1-1" class="headerlink" title="&lt;1&gt;  模板1"></a>&lt;1&gt;  模板1</h3><p><strong>普通类的成员函数，</strong> 也可以定义为函数模板，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">normal_class</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">set</span><span class="params">(T <span class="keyword">const</span>&amp;v)</span></span>&#123;</span><br><span class="line">    value=<span class="keyword">int</span>(v);</span><br><span class="line">  &#125;<span class="comment">//在类内定义</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function">T <span class="title">normal_class::get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> T(value);&#125;<span class="comment">//在类外定义</span></span><br></pre></td></tr></table></figure>

<h3 id="lt-2-gt-模板2-1"><a href="#lt-2-gt-模板2-1" class="headerlink" title="&lt;2&gt;  模板2"></a>&lt;2&gt;  模板2</h3><p><strong>类模板的成员函数，</strong> 也可以有<strong>额外</strong>的模板参数，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> To&gt; <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  To value;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T1 <span class="keyword">const</span>&amp;v)</span></span>&#123;value=To(v);&#125;<span class="comment">//类内定义</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;<span class="function">T1 <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> To&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt; T1 <span class="title">A::get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> T1(value);&#125;<span class="comment">///类外定义</span></span><br></pre></td></tr></table></figure>

<h2 id="4-10-模板转换"><a href="#4-10-模板转换" class="headerlink" title="4.10 模板转换"></a>4.10 模板转换</h2><h3 id="4-10-1-模板参数的具体化-特殊化"><a href="#4-10-1-模板参数的具体化-特殊化" class="headerlink" title="4.10.1 模板参数的具体化/特殊化"></a>4.10.1 模板参数的具体化/特殊化</h3><ul>
<li><p>有时类型并不适用，需要对模板进行特殊化处理，称为“模板特化”</p>
</li>
<li><p>对函数模板，如果有多个模板参数，则特化时必须提供所有参数的特例类型，<strong>不能部分</strong>特化</p>
</li>
<li><p>如：<code>char* sum(char *, char *);</code></p>
<ul>
<li><p>在函数名后用<code>&lt;&gt;</code>括号括起具体类型</p>
<p><code>template&lt;&gt;</code></p>
<p><code>char* sum&lt;char*&gt;(char* a, char* b)&#123;...&#125;</code></p>
</li>
<li><p>由编译器推导出具体类型，函数名为普通类型</p>
</li>
</ul>
<p><code>template&lt;&gt;</code></p>
<p><code>char* sum(char* a, char* b)&#123;...&#125;</code></p>
</li>
</ul>
<h3 id="4-10-2-类模板的部分转化（偏特化）"><a href="#4-10-2-类模板的部分转化（偏特化）" class="headerlink" title="4.10.2 类模板的部分转化（偏特化）"></a>4.10.2 类模板的部分转化（偏特化）</h3><ul>
<li>对于类模版，允许部分特化，即<strong>部分限制模板的通用性</strong>，如：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">Tw</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="comment">//部分特化的模板类：第2个类型参数指定为int</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;</span>T1,<span class="keyword">int</span>&gt;&#123;...&#125;;</span><br><span class="line"><span class="comment">//若指定所有类型，则&lt;&gt;内将为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;</span><span class="keyword">int</span>, <span class="keyword">int</span>&gt;&#123;...&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-11-C-模板"><a href="#4-11-C-模板" class="headerlink" title="4.11 C++模板"></a>4.11 C++模板</h2><blockquote>
<p>如果上面的模板理解起来有点懵，来看看这个吧～</p>
</blockquote>
<p>模板是泛型编程的基础，泛型编程以一种独立于任何特定类型的方式编写代码。</p>
<p>模板用于创建泛型类或函数，库容器如迭代器和算法，都是泛型编程的例子，都使用了模版的概念</p>
<p>每个容器都有一个单一的定义，比如<strong>向量</strong>，我们可以定义许多不同类型的向量，比如<code>vector&lt;int&gt; | vector&lt;string&gt;</code></p>
<h3 id="4-11-1-函数模板"><a href="#4-11-1-函数模板" class="headerlink" title="4.11.1 函数模板"></a>4.11.1 函数模板</h3><p><strong>定义：</strong></p>
<p><code>template&lt;class 形参名1, class 形参名2, ...&gt;返回类型 函数名(参数列表)&#123;函数体&#125;</code></p>
<p><strong>举个例子：</strong></p>
<p><code>template&lt;class T&gt; void swap(T&amp; a, T&amp; b)&#123;&#125;</code></p>
<p>当调用这样的模板函数时，类型T会被调用时的类型所代替，如果<code>swap(a,b)</code>中a，b都是int类型，那么模板函数swap中的形参T就会被int所代替，模板函数swap中的形参T就会被double所代替，模板函数就会变成<code>swap(double &amp;a, double &amp;b)</code>，这样我们的程序中交换变量就不再受限于类型了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> T <span class="keyword">const</span>&amp; <span class="title">Max</span><span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?b:a;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>, j =<span class="number">4</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Max(i, j) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">double</span> tmp=<span class="number">3.14</span>, tmp1 = <span class="number">3.33</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Max(tmp, tmp1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 4</span></span><br><span class="line"><span class="comment">* 3.33</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="4-11-2-类模板"><a href="#4-11-2-类模板" class="headerlink" title="4.11.2 类模板"></a>4.11.2 类模板</h3><p>如同我们定义函数模板一样，我们也可以定义类模板，泛型类声明的一般形式如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> 形参名, <span class="keyword">class</span> 形参名, ...&gt;</span> <span class="class"><span class="keyword">class</span> 类名 &#123;</span>...&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>举个例子：</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  T a;</span><br><span class="line">  T b;</span><br><span class="line">	<span class="function">T <span class="title">hy</span><span class="params">(T c, T &amp;d)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类A中声明了两个类型为T的成员变量a和b，还声明了一个返回类型为T带两个参数类型为T的函数hy</p>
<p><strong>举个例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">T <span class="title">g</span><span class="params">(T a, T b)</span></span>;</span><br><span class="line">  A();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TemplateDemo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> A&lt;T&gt;::A()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> T A&lt;T&gt;::g(T a, T b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a.g(<span class="number">2</span>,<span class="number">3.2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="1-operator关键字-重载操作符-用法"><a href="#1-operator关键字-重载操作符-用法" class="headerlink" title="1 operator关键字(重载操作符)用法"></a>1 operator关键字(重载操作符)用法</h2><blockquote>
<p><code>operator</code>是C++中的关键字，它和运算符一起使用，表示为一个运算符函数。</p>
<p>C++中使用operator可以视为<strong>函数</strong>使用</p>
</blockquote>
<p>作为C++扩展运算符功能的方法，可以理解为：</p>
<ul>
<li>一方面使运算符的使用方法和原来一致</li>
<li>一方面通过函数方式扩展其功能</li>
</ul>
<hr>
<p><strong>为什么使用操作符重载？</strong></p>
<p>对于系统所有操作符，一般情况下，只支持基本数据类型和标准库中提供的class，对于用户自定义的class，如果想支持基本操作，如比较大小，判断是否相等等，需要用户<strong>自定义关于这个操作符</strong>的具体实现。</p>
<hr>
<p><strong>如何声明一个重载的操作符？</strong></p>
<ol>
<li><strong>操作符重载实现为类成员函数</strong></li>
</ol>
<p>重载的操作符在类体中被声明，声明方式和普通成员函数相同，不过他的名字包含关键字<code>operator</code>，及紧跟其后的<code>c++</code>预定义的操作符</p>
<p><strong>举个例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CDBTask&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CDBTask&amp; r)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>后载操作符首先需要确定他的返回值是左值，还是右值，如果是左值则<strong>返回引用</strong>，如果是右值则直接<strong>返回返回值</strong></p>
</li>
<li><p>+号等这样的操作符，没有对象可以容纳改变后的值，对于这样的情况最好返回数值，否则只能在操作符体内<strong>创建临时对象用于容纳改变后的值</strong>，在操作符函数体外还需要释放它</p>
<p>如果返回的是数值，最好在该类的构造函数中增加对该类型数值的转换函数。如：返回值是int类型，那么最好有一个int类型作为参数的构造函数</p>
</li>
<li><p>在增量运算符中，放上一个整数形参，即后增量运行符，作为值返回。对于前增量没有形参，而是引用返回</p>
</li>
</ol>
<p><strong>举个例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(x=<span class="number">3</span>)&#123; m_value = x&#125;</span><br><span class="line">    Test &amp;<span class="keyword">operator</span> ++();  <span class="comment">//前增量</span></span><br><span class="line">    Test &amp;<span class="keyword">operator</span> ++(<span class="keyword">int</span>);<span class="comment">//后增量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Int m_value:</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Test &amp;Test::<span class="keyword">operator</span> ++()</span><br><span class="line">&#123;</span><br><span class="line">  m_value ++;  <span class="comment">//先增量</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回当前对象</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Test Test::<span class="keyword">operator</span> ++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Test <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>; <span class="comment">//创建临时对象</span></span><br><span class="line">  m_value ++;    <span class="comment">//再增量</span></span><br><span class="line">  <span class="keyword">return</span> temp;   <span class="comment">//返回临时对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-OOP/三 基础语法 II"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/10/OOP/%E4%B8%89%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%20II/"
    >OOP 3 -- 基础语法II</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/10/OOP/%E4%B8%89%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%20II/" class="article-date">
  <time datetime="2021-04-10T08:58:57.288Z" itemprop="datePublished">2021-04-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/OOP/">OOP</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <script src="/assets/js/APlayer.min.js"> </script><h1 id="三-基础语法-II"><a href="#三-基础语法-II" class="headerlink" title="三 基础语法 II"></a>三 基础语法 II</h1><h2 id="3-1-构造函数-amp-析构函数"><a href="#3-1-构造函数-amp-析构函数" class="headerlink" title="3.1 构造函数 &amp; 析构函数"></a>3.1 构造函数 &amp; 析构函数</h2><h3 id="3-1-1-构造函数"><a href="#3-1-1-构造函数" class="headerlink" title="3.1.1 构造函数"></a>3.1.1 构造函数</h3><ol>
<li>由编译器自动调用，用于对象数据成员的初始化及其他初始化工作</li>
<li>没有返回值，函数名与类名相同</li>
<li>构造函数可以<strong>重载</strong>，可以使用不同的函数参数进行对象初始化</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> ID;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Student(<span class="keyword">long</span> id) &#123; ID = id; &#125;</span><br><span class="line">  Student(<span class="keyword">int</span> year, <span class="keyword">int</span> order) &#123;</span><br><span class="line">    ID = year*<span class="number">10000</span> + order;</span><br><span class="line">  &#125;</span><br><span class="line">  ...;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不带任何参数的构造函数，称为“默认构造函数”，也称“缺省构造函数”</li>
<li>定义<strong>元素为对象的数组</strong>（<code>ClassName array_var[NUM];</code>）时，类必须提供默认构造函数的定义</li>
<li>使用默认构造函数生成对象时，对象定义格式为：<code>ClassName obj;</code>,而不是<code>ClassName obj();</code></li>
</ul>
<h3 id="3-1-2-构造函数的初始化列表"><a href="#3-1-2-构造函数的初始化列表" class="headerlink" title="3.1.2 构造函数的初始化列表"></a>3.1.2 构造函数的初始化列表</h3><ul>
<li>构造函数可以初始化列表来<strong>初始化成员数据</strong></li>
<li>该列表在定义构造函数时使用，位置出现在函数题左花括号<code>&#123;</code>之前，以冒号<code>:</code>作为开头</li>
<li>使用“数据成员（初始值）”的形式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">  <span class="keyword">long</span> ID;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Student(<span class="keyword">long</span> id) : ID(id) &#123; &#125;<span class="comment">//相当于对ID初始化</span></span><br><span class="line">  Student(<span class="keyword">int</span> year, <span class="keyword">int</span> order) &#123;</span><br><span class="line">    ID = year*<span class="number">10000</span> + order;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>委派构造函数</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Info() &#123; Init(); &#125;</span><br><span class="line">  Info(<span class="keyword">int</span> i) : Info()&#123; id = i; &#125;</span><br><span class="line">  Info(<span class="keyword">char</span> c) : Info()&#123; gender = c; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123; .... &#125; <span class="comment">//其他初始化</span></span><br><span class="line">  <span class="keyword">int</span> id &#123;<span class="number">2016</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> gender &#123;<span class="string">&#x27;M&#x27;</span>&#125;;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-析构函数"><a href="#3-1-3-析构函数" class="headerlink" title="3.1.3 析构函数"></a>3.1.3 析构函数</h3><ul>
<li>一个类只有一个析构函数，名称是“～类名”， 没有函数返回值，没有函数参数</li>
<li>编译器在<strong>对象生命期结束时自动调用类的析构函数</strong>，以便释放对象占用的资源或其它后处理</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassRoom</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">long</span>* ID_list;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ClassRoom() : num(<span class="number">0</span>), ID_list(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">  ...</span><br><span class="line">  ~ClassRoom()&#123;	<span class="comment">//析构函数</span></span><br><span class="line">    <span class="keyword">if</span> (ID_list) <span class="keyword">delete</span>[] ID_list; <span class="comment">//释放内存</span></span><br><span class="line">    <span class="comment">//如果ID_list不为空，则需要释放</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-4-拷贝构造函数"><a href="#3-1-4-拷贝构造函数" class="headerlink" title="3.1.4 拷贝构造函数"></a>3.1.4 <strong>拷贝构造函数</strong></h3><ul>
<li>函数调用时以类的对象为形参或返回类对象时，编译器会生成自动调用“拷贝构造函数”，在<strong>已有对象基础上生成新对象</strong></li>
<li>拷贝构造函数是一种特殊的构造函数，是<strong>同类对象</strong>的常量引用</li>
<li>语义上：用<strong>参数对象的内容初始化当前对象</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Person(<span class="keyword">const</span> Person&amp; src) &#123; id = src.id; ... &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>拷贝构造函数</strong>通常用于：</p>
<ul>
<li>通过使用另一个同类型的对象初始化新创建的对象</li>
<li>复制对象并把它<strong>作为参数传递给函数</strong></li>
<li>复制对象，并从函数返回这个对象</li>
</ul>
<h2 id="3-2-赋值运算符重载"><a href="#3-2-赋值运算符重载" class="headerlink" title="3.2 赋值运算符重载"></a>3.2 赋值运算符重载</h2><ul>
<li>赋值运算符为在类中定义的特殊成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassName&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> ClassName&amp; right)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;right)&#123;<span class="comment">//避免自己赋值给自己(判断内存空间是否相同)</span></span><br><span class="line">		<span class="comment">// 将right对象中内容复制到当前对象中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Test(<span class="keyword">int</span> i) : id(i) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;obj_&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;created\n&quot;</span>;&#125;</span><br><span class="line">	Test&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Test&amp; right)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;right) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;same obj!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;obj_&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; = obj_&quot;</span> &lt;&lt; right.id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">this</span>-&gt;id = right.id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Test a(1), b(2);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; a = a: &quot;</span>;</span><br><span class="line">  a = a;	<span class="comment">/// a.operator = (a);</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; a = b: &quot;</span>;</span><br><span class="line">  a = b;	<span class="comment">/// a.operator = (b);</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	obj_1 created</span></span><br><span class="line"><span class="comment">*	obj_2 created</span></span><br><span class="line"><span class="comment">*	a = a: same obj!</span></span><br><span class="line"><span class="comment">*	a = b: obj1 = obj2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-流运算符重载"><a href="#3-3-流运算符重载" class="headerlink" title="3.3 流运算符重载"></a>3.3 流运算符重载</h2><blockquote>
<p>对象输入输出 </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream&amp; in, Test&amp; dst);</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &gt;&gt; (ostream&amp; out, <span class="keyword">const</span> Test&amp; src);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数名为：<code>operator&gt;&gt;</code> 和 <code>operator&lt;&lt;</code></p>
<blockquote>
<p>流提取运算符&gt;&gt;, 流插入运算符&lt;&lt;来输入和输出内置的数据类型，可以重载流提取运算符和流插入运算符来操作对象等用户自定义的数据类型</p>
</blockquote>
</li>
<li><p>返回值为：<code>istream&amp;</code> 和 <code>ostream&amp;</code>， 均为引用，<strong>需要把运算符重载函数声明为类的友元函数，这样就能不用创建对象而直接调用函数</strong></p>
</li>
<li><p>参数分别为：流对象的引用、目标对象的引用。对于输出流，目标对象还是常量</p>
</li>
</ul>
<p><strong>将流运算符函数声明为类的友元</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Test(<span class="keyword">int</span> i) : id(i) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;obj_&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; created\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; in, Test&amp; dst);</span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; out, <span class="keyword">const</span> Test&amp; src);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>以上类中声明了Test类的两个友元函数 – <strong>全局流运算符重载函数</strong></li>
<li>使得这两个函数在实现时可以访问对象的私有成员（如int id）</li>
</ul>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Test(<span class="keyword">int</span> i) : id(i) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;obj_&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; created\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; in, Test&amp; dst);</span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; out, <span class="keyword">const</span> Test&amp; src);</span><br><span class="line">&#125;;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; in, Test&amp; dst) &#123;</span><br><span class="line">  in &gt;&gt; dst.id;</span><br><span class="line">  <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; out, <span class="keyword">const</span> Test&amp; src) &#123;</span><br><span class="line">  out &lt;&lt; src.id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Test <span class="title">obj</span><span class="params">(<span class="number">1</span>)</span></span>;	<span class="built_in">cout</span> &lt;&lt; obj;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; obj;	<span class="built_in">cout</span> &lt;&lt; obj;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* obj_1 created</span></span><br><span class="line"><span class="comment">* 1</span></span><br><span class="line"><span class="comment">* 2	// 修改obj.id = 2</span></span><br><span class="line"><span class="comment">* 2 // 打印obj.id = 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="3-4-函数运算符重载"><a href="#3-4-函数运算符重载" class="headerlink" title="3.4 函数运算符重载"></a>3.4 函数运算符重载</h2><ul>
<li>函数运算符<code>()</code>也能重载，使对象看上去像是一个函数名</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">operator</span><span class="params">()</span> <span class="params">(Parameters)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassName obj;</span><br><span class="line">Obj(real_parameters);</span><br><span class="line"><span class="comment">//-&gt;Obj.operator() (real_parameters);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;operator() called.&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Test sum;</span><br><span class="line">  <span class="keyword">int</span> s = sum(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">/// sum对象看上去像是一个函数，故也称&quot;函数对象&quot;</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a+b=&quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>再来一个例子</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Less</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> thres_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Less(<span class="keyword">int</span> th) : thres_(th) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Less::operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (value&lt;thres_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Filter</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> num, Less l)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(l(arr[i]))&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> tmp;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;tmp:&quot;</span>; <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">  <span class="function">Less <span class="title">l</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">  Filter(arr, <span class="number">5</span>, l);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="3-5-下标-amp-自增减-运算符重载"><a href="#3-5-下标-amp-自增减-运算符重载" class="headerlink" title="3.5 下标&amp;自增减 运算符重载"></a>3.5 下标&amp;自增减 运算符重载</h2><h3 id="3-5-1-数组运算符-重载"><a href="#3-5-1-数组运算符-重载" class="headerlink" title="3.5.1 数组运算符[]重载"></a>3.5.1 数组运算符[]重载</h3><ul>
<li>函数声明 ：<code>返回类型 operator[](参数);</code></li>
<li>如果返回类型是引用，则数组运算符调用可以出现在等号左边，接受赋值，即</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Obj[index] = value;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果返回类型不是引用，则只能出现在等号右边</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Var = Obj[index];</span><br></pre></td></tr></table></figure>

<h3 id="3-5-2-重载前缀-后缀–"><a href="#3-5-2-重载前缀-后缀–" class="headerlink" title="3.5.2 重载前缀++/后缀–"></a>3.5.2 重载前缀++/后缀–</h3><ul>
<li><p><strong>前缀运算符重载声明</strong></p>
<ul>
<li><code>ReturnType operator++();</code></li>
<li><code>ReturnType operator--();</code></li>
</ul>
</li>
<li><p><strong>后缀运算符重载声明</strong></p>
<ul>
<li><code>ReturnType operator++(int dummy);</code></li>
<li><code>ReturnType operator--(int dummy);</code></li>
</ul>
</li>
<li><p>通过在函数参数中的哑元参数dummy来区分前缀与后缀的同名重载</p>
</li>
</ul>
<blockquote>
<p>哑元：函数体语句中没有使用该参数</p>
</blockquote>
<h2 id="3-6-静态成员与常量成员"><a href="#3-6-静态成员与常量成员" class="headerlink" title="3.6 静态成员与常量成员"></a>3.6 静态成员与常量成员</h2><h3 id="3-6-1-类中的静态成员"><a href="#3-6-1-类中的静态成员" class="headerlink" title="3.6.1 类中的静态成员"></a>3.6.1 类中的静态成员</h3><ol>
<li>在类型前面加上static修饰的数据成员，隶属于类，称为类的静态成员变量，也称“类变量”<ul>
<li>静态数据成员<strong>被该类的所有对象共享（</strong>即所有对象中的数据与实际上处于同一内存位置</li>
<li>静态数据需要在实现文件中赋初值：<code>Type ClassName::static_var = Value;</code></li>
</ul>
</li>
<li>返回值类型前面加上static修饰的成员函数，为静态成员函数，他们调用非静态成员函数</li>
<li>类的静态成员（数据、函数）可以通过对象类访问，也可以通过类名来访问</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Test() &#123;count++;&#125;</span><br><span class="line">  ~Test() &#123;count--;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">how_many</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> count;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Test::count = <span class="number">0</span>; 	<span class="comment">//定义静态变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Test t)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;in print(), Test#:&quot;</span> &lt;&lt; t.how_many() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test t1;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Test#: &quot;</span> &lt;&lt; Test::how_many() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// Test#:1</span></span><br><span class="line">  </span><br><span class="line">  Test t2;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Test#: &quot;</span> &lt;&lt; Test::how_many() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// TEst#:1</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Test#:&quot;</span> &lt;&lt; t1.how_many &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; t2.how_many(); <span class="comment">//0 0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造：count++，但是这里因为没有<strong>拷贝构造函数</strong>，使最后出现的值相同</p>
<p><strong>析构：</strong> count–， 所以最后都为0</p>
</blockquote>
<h3 id="3-6-2-类中的常量成员"><a href="#3-6-2-类中的常量成员" class="headerlink" title="3.6.2 类中的常量成员"></a>3.6.2 类中的常量成员</h3><ol>
<li>使用const修饰的数据成员，称为类的常量数据成员，在对象的整个生命周期都不可更改<ul>
<li>常量数据成员<strong>只能在构造的初始化列表</strong>中被设置，不允许在函数体中通过复制来设置</li>
</ul>
</li>
<li>如果用const来修饰成员函数，则该成员函数在实现时<strong>不能修改类的数据成员–即函数体中不能有改变对象状态的语句</strong><ul>
<li>如果对象被定义为<strong>常量</strong>，则它只能调用以const修饰的成员函数，其他普通成员函数不允许调用</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ID;   <span class="comment">//ID常量，不可修改</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> tmp) : ID(tmp)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MyID</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> ID;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">who</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ID;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Test.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">obj1</span><span class="params">(<span class="number">1233</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;static: &quot;</span> &lt;&lt; obj1.MyID() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;non-static: &quot;</span> &lt;&lt; obj1.who() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Test <span class="title">obj2</span><span class="params">(<span class="number">1234</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;static: &quot;</span> &lt;&lt; obj2.MyID() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;non-static:&quot;</span> &lt;&lt; <span class="string">&quot;no output&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*static: 1233</span></span><br><span class="line"><span class="comment">*non-static: 1233</span></span><br><span class="line"><span class="comment">*static: 1234</span></span><br><span class="line"><span class="comment">*non-static:no output</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="3-7-对象组合"><a href="#3-7-对象组合" class="headerlink" title="3.7 对象组合"></a>3.7 对象组合</h2><h3 id="3-7-1-包含其他类的对象"><a href="#3-7-1-包含其他类的对象" class="headerlink" title="3.7.1 包含其他类的对象"></a>3.7.1 包含其他类的对象</h3><ol>
<li><p>可以在类中使用其他类来定义数据成员，通常称之为“子对象”。这种<strong>包含与被包含</strong>的对象间的关系称为“组合”， <strong>组合关系可以嵌套</strong></p>
<blockquote>
<p>如同“俄罗斯套娃”</p>
</blockquote>
</li>
<li><p>子对象<strong>构造时如果需要参数</strong>，<strong>则</strong>应该在当前类的构造函数的<strong>初始化列表</strong>中进行。如果<strong>使用默认构造函数来构造子对象</strong>，则不用做任何处理</p>
</li>
<li><p>对象的构造与析构次序</p>
<ul>
<li><p>先完成子对象构造，再完成当前对象的构造</p>
<blockquote>
<p>先从最内部开始构造</p>
</blockquote>
</li>
<li><p><strong>对象析构的次序与对象构造的次序</strong>是相反的</p>
<blockquote>
<p>先从最外部析构</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="3-8-移动构造函数（C-11）"><a href="#3-8-移动构造函数（C-11）" class="headerlink" title="3.8 移动构造函数（C++ 11）"></a>3.8 移动构造函数（C++ 11）</h2><ol>
<li><p>语法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName(ClassName&amp;&amp;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>目的</p>
<ul>
<li><p>来偷<strong>“临时变量”</strong>中的资源（如内存</p>
</li>
<li><p>临时变量被编译器设置为常量形式，使用“拷贝构造”函数无法将资源“<strong>偷</strong>出来”</p>
<blockquote>
<p>“偷”是对原对象的一种改动，违反常量的限制</p>
</blockquote>
</li>
<li><p>基于“右值引用”「&amp;&amp;」定义的“移动构造”函数支持接受临时变量，能“偷”出临时变量中的资源</p>
</li>
</ul>
</li>
</ol>
<p>通过增加<code>-fno-elide-constructors</code>可以避免编译器优化而忽略部分过程的问题</p>
<h2 id="3-9-default修饰符"><a href="#3-9-default修饰符" class="headerlink" title="3.9 default修饰符"></a>3.9 default修饰符</h2><p><strong>编译器自动生成的成员函数：</strong></p>
<p>如果以下<strong>成员函数用户</strong>都没有被类实现，则编译器会自动为类生成他们的缺省实现</p>
<ul>
<li>默认构造函数 – 空函数，什么也不做</li>
<li>析构函数 – 空函数，什么也不做</li>
<li>拷贝构造函数 – 按bit位复制对象所占内存的内容</li>
<li>移动构造函数 – 与默认拷贝构造函数一样</li>
<li>赋值运算符重载 – 与默认拷贝构造函数一样</li>
</ul>
<p>如果用户定义了上述某个成员函数，则编译器不再自动提供相应的默认实现</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-OOP/二 基础语法 I"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/08/OOP/%E4%BA%8C%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%20I/"
    >OOP 2 -- 基础语法I</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/08/OOP/%E4%BA%8C%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%20I/" class="article-date">
  <time datetime="2021-04-08T12:18:32.824Z" itemprop="datePublished">2021-04-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/OOP/">OOP</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <script src="/assets/js/APlayer.min.js"> </script><h1 id="二-基础语法-I"><a href="#二-基础语法-I" class="headerlink" title="二 基础语法 I"></a>二 基础语法 I</h1><h2 id="2-1-变量定义"><a href="#2-1-变量定义" class="headerlink" title="2.1 变量定义"></a>2.1 变量定义</h2><ol>
<li><p><strong>auto</strong>变量</p>
<p>由编译器根据上下文自动确定变量的类型，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> f=<span class="number">4.0f</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针变量的动态生成与删除</p>
<ul>
<li>通过new/delete来动态生成和释放内存</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>;	<span class="comment">//开辟一个可以放int型的内存空间</span></span><br><span class="line"><span class="keyword">int</span> *<span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];	</span><br><span class="line"><span class="keyword">delete</span> prt;	<span class="comment">//删除指针变量所指向的内存单元</span></span><br><span class="line"><span class="keyword">delete</span>[] <span class="built_in">array</span>;	<span class="comment">//删除多个单元组成的内存块(删除指向该内存的地址的值)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>左值引用</strong></p>
<p>在定义的时候先初始化，给另一个变量起别名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v0;</span><br><span class="line"><span class="keyword">int</span> &amp;v1 = v0;<span class="comment">//v1为v0的别名，在内存中是同一单元的两个不同名字</span></span><br></pre></td></tr></table></figure>

<ul>
<li>引用必须在定义时进行初始化</li>
<li>函数的参数也可以是引用类型，改变形参将改变实参</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = b;</span><br><span class="line">	b = a;</span><br><span class="line">	a = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值可以是引用类型，但是不能是函数里面定义的临时变量</li>
</ul>
</li>
<li><p><strong>右值引用</strong></p>
<ul>
<li>不能<strong>取地址的、没有名字</strong>的就是右值【匿名变量】</li>
<li><code>int &amp;&amp;sum = 3+4;</code>即让sum保存3+4的结果</li>
<li>典型应用是在函数参数中：<code>void AcceptRvalueRef(T &amp;&amp; s)&#123;...&#125;</code>。目的是减少临时变量传给函数时，把内容复制过去带来的时间上的开销</li>
</ul>
</li>
</ol>
<h2 id="2-2-变量初始化、类型推导及基于范围的循环"><a href="#2-2-变量初始化、类型推导及基于范围的循环" class="headerlink" title="2.2 变量初始化、类型推导及基于范围的循环"></a>2.2 变量初始化、类型推导及基于范围的循环</h2><h3 id="2-2-1-变量初始化"><a href="#2-2-1-变量初始化" class="headerlink" title="2.2.1 变量初始化"></a>2.2.1 变量初始化</h3><ol>
<li>初始化列表</li>
</ol>
<ul>
<li><p><code>int a[] = &#123;1, 3, 5&#125;;</code></p>
</li>
<li><p>或：<code>int a[]&#123;1, 3, 5&#125;</code>与上句等效</p>
</li>
</ul>
<ol start="2">
<li>变量的初始化方式</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a = &#123;<span class="number">3</span>+<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">3</span>+<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">3</span>+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> *i = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);<span class="comment">//分配一个内存空间能放int,这个空间存着10</span></span><br><span class="line"><span class="keyword">double</span> *d = <span class="keyword">new</span> <span class="keyword">double</span>&#123;<span class="number">1.2f</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-类型推导"><a href="#2-2-2-类型推导" class="headerlink" title="2.2.2 类型推导"></a>2.2.2 类型推导</h3><p>使用<code>decltype</code>对变量/表达式结果的类型进行推导</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span> <span class="keyword">char</span>* name; &#125;anou_u;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">decltype</span>(anou_u) id;</span><br><span class="line">	<span class="keyword">int</span> score</span><br><span class="line">&#125;anou_s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">decltype</span>(anou_s) as;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; as[<span class="number">0</span>].id.name;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-基于范围的for循环"><a href="#2-2-3-基于范围的for循环" class="headerlink" title="2.2.3 基于范围的for循环"></a>2.2.3 基于范围的for循环</h3><p>用“:”分为两部分：(迭代变量 : 遍历数组)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e:arr)&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-3-函数重载"><a href="#2-3-函数重载" class="headerlink" title="2.3 函数重载"></a>2.3 函数重载</h2><p>同一个名字，有不同的函数体，要求传入参数类型不一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> *msg)</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个同名的函数实现之间，必须保证至少有一个函数参数类型有区别。</p>
<p>返回值、参数名称等不能作为区分标识。</p>
<h2 id="2-4-函数参数缺省-amp-追踪返回类型"><a href="#2-4-函数参数缺省-amp-追踪返回类型" class="headerlink" title="2.4 函数参数缺省 &amp; 追踪返回类型"></a>2.4 函数参数缺省 &amp; 追踪返回类型</h2><h3 id="2-4-1-函数参数缺省"><a href="#2-4-1-函数参数缺省" class="headerlink" title="2.4.1 函数参数缺省"></a>2.4.1 函数参数缺省</h3><p>函数参数在定义时设置默认值（缺省值），这样在调用时，如果没有设置参数，函数会自动赋值给参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> *msg = <span class="string">&quot;hello&quot;</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="string">&quot;#&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  print(<span class="string">&quot;HaHa...&quot;</span>);</span><br><span class="line">  print();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// HaHa...#hello#</span></span><br></pre></td></tr></table></figure>

<ul>
<li>有缺省的函数参数，必须写在最后一个</li>
<li>如果带有多个，都只能在没有缺省值的参数后面出现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">int</span> score, <span class="keyword">char</span> *msg = <span class="string">&quot;hello&quot;</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; score &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; msg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-追踪返回类型"><a href="#2-4-2-追踪返回类型" class="headerlink" title="2.4.2 追踪返回类型"></a>2.4.2 追踪返回类型</h3><p>可以将函数返回类型的声明信息放到函数参数列表的后面进行声明</p>
<ul>
<li>普通函数声明：<code>int func(char *ptr, int val);</code></li>
<li><strong>追踪返回类型的函数声明：</strong> <code>auto func(char *ptr, int val) -&gt; int</code></li>
</ul>
<blockquote>
<p>追踪返回类型在原本函数返回值的位置使用auto，箭头由编译器找寻</p>
</blockquote>
<h2 id="2-5-类的定义"><a href="#2-5-类的定义" class="headerlink" title="2.5 类的定义"></a>2.5 类的定义</h2><p>用户自定义类型 – 类CLASS</p>
<ul>
<li>一种用户自定义的类型，包含函数与数据的特殊“结构体”</li>
<li>类中包含的函数，称为“成员函数”；包含的数据，称为“数据成员”</li>
<li>类中函数既可以在类中给出定义，也可以在类外给出定义</li>
<li>类的成员（数据、函数）可以根据需要分成组，不同族设置不同的访问权限</li>
</ul>
<blockquote>
<p>Public(公有)， private（私有）， protected（保护）</p>
</blockquote>
<p>通过<code>“对象名.成员名”</code>的形式，可以使用对象的数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MATRIX_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MATRIX_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> data[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">char</span> dir)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-1-在实现文件中定义类"><a href="#2-5-1-在实现文件中定义类" class="headerlink" title="2.5.1 在实现文件中定义类"></a>2.5.1 在实现文件中定义类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// matrix.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;matrix.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Matrix::fill</span><span class="params">(<span class="keyword">char</span> dir)</span></span>&#123;</span><br><span class="line">  ...<span class="comment">//函数实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通常，类的声明放在头文件中，而类的成员函数放在实现文件中</li>
<li>为了便于管理和代码复用，一般将不同的类分别保存为不同的头文件和实现文件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> data[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">char</span> dir)</span></span>&#123;</span><br><span class="line">    ...;	<span class="comment">// &lt;1&gt;类内定义成员函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">-------------</span><br><span class="line">  <span class="comment">//一般放在单独的cpp文件中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Matrix::fill</span><span class="params">(<span class="keyword">char</span> dir)</span></span>&#123;</span><br><span class="line">  ...;	<span class="comment">// &lt;2&gt;类外定义成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-2-this指针"><a href="#2-5-2-this指针" class="headerlink" title="2.5.2 this指针"></a>2.5.2 this指针</h3><blockquote>
<p>所有成员函数的参数重，隐含一个只想当前对象的指针变量<code>this</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> data[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">char</span> dir)</span></span>&#123;</span><br><span class="line">    ...;	<span class="comment">// &lt;1&gt;类内定义成员函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;data[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//等价于data[0][0]=1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">-------------</span><br><span class="line">  <span class="comment">//一般放在单独的cpp文件中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Matrix::fill</span><span class="params">(<span class="keyword">char</span> dir)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;data[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;	<span class="comment">// &lt;2&gt;类外定义成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-类成员的访问权限与友元"><a href="#2-6-类成员的访问权限与友元" class="headerlink" title="2.6 类成员的访问权限与友元"></a>2.6 类成员的访问权限与友元</h2><h3 id="2-6-1-类成员的访问权限"><a href="#2-6-1-类成员的访问权限" class="headerlink" title="2.6.1 类成员的访问权限"></a>2.6.1 类成员的访问权限</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matric</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">char</span> dir)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> data[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line">&#125;; <span class="comment">//&lt;1&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data[<span class="number">6</span>][<span class="number">6</span>];	<span class="comment">//class中成员的缺省属性为private</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">char</span> dir)</span></span>;</span><br><span class="line">&#125;; <span class="comment">//&lt;2&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>访问对象的成员（数据、函数）</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;matrix.h&quot;</span>	<span class="comment">// Matrix类的声明</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Matrix obj;	<span class="comment">//定义变量（对象）</span></span><br><span class="line">  obj.fill(<span class="string">&#x27;u&#x27;</span>);	<span class="comment">//访问公有成员</span></span><br><span class="line">  <span class="comment">//可以使用：obj-&gt;fill(&#x27;u&#x27;);</span></span><br><span class="line">  obj.data[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">23</span>;	<span class="comment">//私有！Error！</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不允许用<code>.</code>访问对象的私有/保护成员，只能访问公有属性</p>
</blockquote>
<h3 id="2-6-2-友元"><a href="#2-6-2-友元" class="headerlink" title="2.6.2 友元"></a>2.6.2 友元</h3><blockquote>
<p>当需要允许某些函数访问对象的私有成员，可以通过声明该函数类的<strong>“友元”</strong>来实现</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Test obj)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Test obj)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; obj.id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test类中声明了Test类的友元函数print</span></span><br><span class="line"><span class="comment">// 函数在实现时可以访问Test类定义对象的私有成员（如int id）</span></span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-OOP/一 编程环境&amp;简介"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/08/OOP/%E4%B8%80%20%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83&%E7%AE%80%E4%BB%8B/"
    >OOP 1 -- 头文件&amp;make</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/08/OOP/%E4%B8%80%20%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83&%E7%AE%80%E4%BB%8B/" class="article-date">
  <time datetime="2021-04-08T10:03:06.631Z" itemprop="datePublished">2021-04-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/OOP/">OOP</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <script src="/assets/js/APlayer.min.js"> </script><h1 id="一-编程环境-amp-简介"><a href="#一-编程环境-amp-简介" class="headerlink" title="一 编程环境&amp;简介"></a>一 编程环境&amp;简介</h1><h2 id="1-1-编程环境-amp-工具"><a href="#1-1-编程环境-amp-工具" class="headerlink" title="1.1 编程环境 &amp; 工具"></a>1.1 编程环境 &amp; 工具</h2><p>源代码的基本接口：头文件与编译指令 + 函数「辅助/主函数」定义</p>
<p><strong>编译、链接：</strong>gcc -c：<strong>编译</strong>—-&gt; <code>.o</code>文件。或者直接<code>g++</code>, 直接生成<code>.out</code>文件，编译链接一步完成</p>
<h2 id="1-2-源程序拆分"><a href="#1-2-源程序拆分" class="headerlink" title="1.2 源程序拆分"></a>1.2 源程序拆分</h2><p>源代码变复杂时—》 拆开，将一个cpp分成多个cpp，便于维护和交流</p>
<p>通常把辅助函数抽取出来，自己编写的一般用””包括起来，&lt;&gt;为系统含有的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//func.h </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//func.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>防止重复包含导致的编译错误</strong></p>
<p><strong>传统：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//func.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>增加预编译指令：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ADD </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这样多次出现func.h，也不会出现编译错误,这样是防止头文件被重复引用，在头文件中定义了全局变量时会引起重复定义</p>
<blockquote>
<p>不是一定要加，但是不管怎样，使用#ifndef xxx #define xxx #endif或者其他方式避免头文件重复包含，只有好处没有坏处～</p>
</blockquote>
<h2 id="1-3-多文件编程链接的方法"><a href="#1-3-多文件编程链接的方法" class="headerlink" title="1.3 多文件编程链接的方法"></a>1.3 多文件编程链接的方法</h2><p>make工具</p>
<ul>
<li>编写专门格式的MakeFile文件</li>
<li>大型编译自动化的一种工具<ul>
<li>减少编译花费的时间，确保使用正确的选项进行编译</li>
</ul>
</li>
</ul>
<p><strong>格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任务名： 前提条件「源代码的名字」</span><br></pre></td></tr></table></figure>

<p><strong>执行MakeFile的基本方法</strong></p>
<ul>
<li><p>1: make </p>
<blockquote>
<p>执行第一个任务</p>
</blockquote>
</li>
<li><p>2：make 任务名</p>
<ul>
<li>make clean； make </li>
</ul>
</li>
<li><p>3:make 其他任务： make -f makefile的文件名</p>
</li>
<li><p>4:<code>make -f makefileName</code>: make -f my_mkfile.exe</p>
</li>
</ul>
<h2 id="2-main函数的命令行参数"><a href="#2-main函数的命令行参数" class="headerlink" title="2 main函数的命令行参数"></a>2 main函数的命令行参数</h2><h3 id="2-1-命令行参数"><a href="#2-1-命令行参数" class="headerlink" title="2.1 命令行参数"></a>2.1 命令行参数</h3><p>通常情况下，return 0表示没有错误， return 1 表示出现错误</p>
<p>给出<code>#ifndef/#define/#endif</code>格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> A_H  <span class="comment">//	if not degine a.h</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A_H	 <span class="comment">//	接下来就需要引入a.h</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>			 <span class="comment">//	否则不需要引入</span></span></span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-uCore/Lab 1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/05/uCore/Lab%201/"
    >uCore Lab 1</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/05/uCore/Lab%201/" class="article-date">
  <time datetime="2021-04-05T13:47:03.043Z" itemprop="datePublished">2021-04-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/uCore/">uCore</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <script src="/assets/js/APlayer.min.js"> </script><h1 id="1-实验准备"><a href="#1-实验准备" class="headerlink" title="1 实验准备"></a>1 实验准备</h1><p>os需要通过某种机制加载并运行它，在这里我们通过更加简单的软件–boot loader来完成这些工作，为此，我们需要一个能够切换到x86的保护模式并显示字符的bootloader，为启动ucore作准备。lab1提供了一个非常小的bootloader和ucore OS，整个bootloader执行代码小于512字节，这样才能放到硬盘的主引导扇区中。</p>
<h1 id="2-实验内容"><a href="#2-实验内容" class="headerlink" title="2 实验内容"></a>2 实验内容</h1><p>lab1中包含一个bootloader和一个OS，这个bootloader可以切换到x86保护模式，能够读磁盘并加载ELF执行文件格式，并显示字符。</p>
<h2 id="练习一：make生成执行文件"><a href="#练习一：make生成执行文件" class="headerlink" title="练习一：make生成执行文件"></a>练习一：make生成执行文件</h2><h3 id="1-1-ucore-img镜像文件是如何生成的（需要详细的解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果）"><a href="#1-1-ucore-img镜像文件是如何生成的（需要详细的解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果）" class="headerlink" title="1.1 ucore.img镜像文件是如何生成的（需要详细的解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果）"></a>1.1 ucore.img镜像文件是如何生成的（需要详细的解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果）</h3><ol>
<li>GCC编译选项</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	-g 增加gdb调试信息</span><br><span class="line">	-Wall 显示警告信息</span><br><span class="line">	-O2 优化处理（有0， 1， 2， 3， 0为不优化）</span><br><span class="line">	-fno-builtin 只接受以“__”开头的内建函数</span><br><span class="line">	-ggdb 让gcc为gdb生成更丰富的调试信息</span><br><span class="line">	-m32 编译32位程序</span><br><span class="line">	-gstabs 这个选项以stabs格式生成调试信息，但是不包括gdb调试信息</span><br><span class="line">	-nostdinc 不在标准系统目录中搜索头文件，只在-l指定的目录中搜索</span><br><span class="line">	-fstack-protector-all 启用堆栈保护，为所有函数插入保护代码</span><br><span class="line">	-E 仅做预处理，不尽心编译、汇编和链接</span><br><span class="line">	-x c 指明使用的语言为C语言</span><br><span class="line"></span><br><span class="line">LDD Flags</span><br><span class="line">	-nostdlib	不链接系统标准启动文件和标准库文件，只把指定的文件传递给连接器</span><br><span class="line">	-m elf\_i386 使用elf_i386模拟器</span><br><span class="line">	-N 把text和data节设置为可读写，同时取消数据节的页对齐，取消对共享库的链接</span><br><span class="line">	-e func	以符号func的位置作为程序开始运行的位置</span><br><span class="line">	-Ttext addr	连接时将初始地址重定向为addr</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编译bootloader</li>
</ol>
<blockquote>
<p>用来加载Kernel </p>
<p>先把bootasm.S, bootmain.c 编译成目标文件</p>
<p>再使用连接器链接到一起，使用start符号作入口，并且指定text段在程序中的绝对位置为0x7c00，0x7c00为os一开始加载的地址</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//bootasm.o</span><br><span class="line">+ cc boot/bootasm.S</span><br><span class="line">gcc -Iboot/ -fno-builtin  -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br><span class="line"></span><br><span class="line">//生成bootmain.o</span><br><span class="line">+ cc boot/bootmain.c</span><br><span class="line">gcc -Iboot/ -fno-builtin  -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o</span><br><span class="line"></span><br><span class="line">//ld bin/bootblock</span><br><span class="line">ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;obj/bootblock.out&#x27;</span> size: 468 bytes</span><br><span class="line">build 512 bytes boot sector: <span class="string">&#x27;bin/bootblock&#x27;</span> success!</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>编译Kernel</strong></li>
</ol>
<blockquote>
<p>操作系统本身</p>
<p>先把.c文件和.S汇编文件生成目标文件，之后使用链接起生成Kernel</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+ cc kern/init/init.c</span><br><span class="line">gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o</span><br><span class="line">+ cc kern/libs/readline.c</span><br><span class="line">gcc -Ikern/libs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/libs/readline.c -o obj/kern/libs/readline.o</span><br><span class="line">+ cc kern/libs/stdio.c</span><br><span class="line">gcc -Ikern/libs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/libs/stdio.c -o obj/kern/libs/stdio.o</span><br><span class="line">+ cc kern/debug/kdebug.c</span><br><span class="line">gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/debug/kdebug.c -o obj/kern/debug/kdebug.o</span><br><span class="line">+ cc kern/debug/kmonitor.c</span><br><span class="line">gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/debug/kmonitor.c -o obj/kern/debug/kmonitor.o</span><br><span class="line">+ cc kern/debug/panic.c</span><br><span class="line">gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/debug/panic.c -o obj/kern/debug/panic.o</span><br><span class="line">+ cc kern/driver/clock.c</span><br><span class="line">gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/driver/clock.c -o obj/kern/driver/clock.o</span><br><span class="line">+ cc kern/driver/console.c</span><br><span class="line">gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/driver/console.c -o obj/kern/driver/console.o</span><br><span class="line">+ cc kern/driver/intr.c</span><br><span class="line">gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/driver/intr.c -o obj/kern/driver/intr.o</span><br><span class="line">+ cc kern/driver/picirq.c</span><br><span class="line">gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/driver/picirq.c -o obj/kern/driver/picirq.o</span><br><span class="line">+ cc kern/<span class="built_in">trap</span>/trap.c</span><br><span class="line">gcc -Ikern/<span class="built_in">trap</span>/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/<span class="built_in">trap</span>/trap.c -o obj/kern/<span class="built_in">trap</span>/trap.o</span><br><span class="line">+ cc kern/<span class="built_in">trap</span>/trapentry.S</span><br><span class="line">gcc -Ikern/<span class="built_in">trap</span>/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/<span class="built_in">trap</span>/trapentry.S -o obj/kern/<span class="built_in">trap</span>/trapentry.o</span><br><span class="line">+ cc kern/<span class="built_in">trap</span>/vectors.S</span><br><span class="line">gcc -Ikern/<span class="built_in">trap</span>/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/<span class="built_in">trap</span>/vectors.S -o obj/kern/<span class="built_in">trap</span>/vectors.o</span><br><span class="line">+ cc kern/mm/pmm.c</span><br><span class="line">gcc -Ikern/mm/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/mm/pmm.c -o obj/kern/mm/pmm.o</span><br><span class="line">+ cc libs/printfmt.c</span><br><span class="line">gcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/printfmt.c -o obj/libs/printfmt.o</span><br><span class="line">+ cc libs/string.c</span><br><span class="line">gcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/string.c -o obj/libs/string.o</span><br><span class="line"></span><br><span class="line">+ ld bin/kernel</span><br><span class="line">ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/<span class="built_in">trap</span>/trap.o obj/kern/<span class="built_in">trap</span>/trapentry.o obj/kern/<span class="built_in">trap</span>/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>编译sign</strong></li>
</ol>
<blockquote>
<p>用于生成一个复合规范的硬盘主引导扇区</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ cc tools/sign.c</span><br><span class="line">gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o</span><br><span class="line">gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign</span><br></pre></td></tr></table></figure>

<p><strong>在这里也有第二问的答案，我们来看看sign.c</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less tools/sign.c</span><br></pre></td></tr></table></figure>

<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210405213234119.png" alt="image-20210405213234119" style="zoom:50%;">

<p>第一个扇区为bootloader的位置，通过0x7c00指向这，前510个字节全部为0（用于初始化），后面第511和512个字节必须为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf[<span class="number">510</span>] = <span class="number">0x55</span>;</span><br><span class="line">buf[<span class="number">511</span>] = <span class="number">0xAA</span>;</span><br></pre></td></tr></table></figure>

<p>否则硬盘启动会失败</p>
<ol start="5">
<li><strong>生成ucore.img</strong></li>
</ol>
<ul>
<li>dd - 转换和拷贝文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>	表示输入文件，如果不指定<span class="keyword">if</span>，默认会从stdin中读取输入</span><br><span class="line">of	表示输出文件，如果不指定of，默认会将stdout作为默认输出</span><br><span class="line">bs	代表字节为单位的块大小</span><br><span class="line">count 	表示被复制的块数</span><br><span class="line">/dev/zero	是一个字符设备，会不断返回0值字节(\0)</span><br><span class="line">conv=notrunc	输入文件的时候，源文件不会被截断</span><br><span class="line">seek=blocks		从输出文件开头跳过blocks（512字节）个块后再开始复制</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>过程：</strong> 生成一个空的软盘镜像，然后把bootloader以不截断的方式填充到开始的块中，然后kernel会跳过bootloader所在的块，再填充</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=bin/ucore.img count=10000</span><br><span class="line">dd <span class="keyword">if</span>=bin/bootblock of=bin/ucore.img conv=notrunc</span><br><span class="line">dd <span class="keyword">if</span>=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</span><br></pre></td></tr></table></figure>

<h3 id="1-2-主引导扇区的特征是什么"><a href="#1-2-主引导扇区的特征是什么" class="headerlink" title="1.2 主引导扇区的特征是什么"></a>1.2 主引导扇区的特征是什么</h3><p>上面提过的，一个磁盘主引导扇区只有512个字节，并且<code>buf[510] = 0x55</code>, <code>buf[511] = 0xAA</code></p>
<h2 id="练习2：使用qemu执行并调试lab1中的软件"><a href="#练习2：使用qemu执行并调试lab1中的软件" class="headerlink" title="练习2：使用qemu执行并调试lab1中的软件"></a>练习2：使用qemu执行并调试lab1中的软件</h2><ol>
<li>从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行</li>
<li>在初始化位置0x7c00设置实地址断点，测试断点正常</li>
<li>在调用qemu时增加<code>-d </code></li>
</ol>
<h3 id="2-1-qemu-system-i386"><a href="#2-1-qemu-system-i386" class="headerlink" title="2.1 qemu-system-i386"></a>2.1 qemu-system-i386</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-hda file	硬盘选项</span><br><span class="line">-parallel dev	重定向虚拟并口到主机设备，最多可虚拟3个并口</span><br><span class="line">-serial dev	重定向虚拟串口到主机设备</span><br><span class="line">	vc: 虚拟控制台</span><br><span class="line">	pty: 仅仅linux有效，虚拟tty（一个虚拟伪终端会被立刻分配）</span><br><span class="line">	none: 没有设备被分配</span><br><span class="line">  null: 无效设备</span><br><span class="line">-S	启动的时候不直接从CPU启动，需要在窗口中按c来继续</span><br><span class="line">-s	shorthand <span class="keyword">for</span> -gdb tcp::1234，打开端口1234，供gdb来调试</span><br></pre></td></tr></table></figure>

<h3 id="2-2-gdb"><a href="#2-2-gdb" class="headerlink" title="2.2 gdb"></a>2.2 gdb</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-x	从文件中执行gdb命令</span><br><span class="line">-q	不打印介绍和版权信息</span><br><span class="line">-tui	将终端屏幕分成原文本窗口和控制台的多个子窗口，能够一边看源码一边调试</span><br><span class="line"></span><br><span class="line">-S -s 使得qemu在执行第一条指令之前停下来，然后sleep两秒给qemu充分的时间准备等待连接，接下来使用gdb调试工具，-tui提供代码与命令行分屏查看的界面，tools/gdbinit中存放的事gdb调试</span><br></pre></td></tr></table></figure>

<p>一开始进入<code>tools\gdbinit</code>文件夹下修改<code>gdbinit</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> arch i8086</span><br><span class="line">target post: 1234</span><br></pre></td></tr></table></figure>

<h2 id="练习3-分析bootloader进入保护模式的过程"><a href="#练习3-分析bootloader进入保护模式的过程" class="headerlink" title="练习3:分析bootloader进入保护模式的过程"></a>练习3:分析bootloader进入保护模式的过程</h2><ul>
<li><strong>BIOS通过读取硬盘主引导扇区到内存，并跳转到对应内存中的位置执行bootloader是如何从实模式进入保护模式</strong></li>
</ul>
<p>需要了解；</p>
<ul>
<li>为何开启A20，如何开启A20</li>
<li>如何初始化GDT表</li>
<li>如何使能和进入保护模式</li>
</ul>
<h3 id="3-1-开启A20"><a href="#3-1-开启A20" class="headerlink" title="3.1 开启A20"></a>3.1 开启A20</h3><p>bootloader入口为start，根据bootloader相关知识可以知道，bootloader会被BIOS加载到内存的0x7c00处，此时cs=0，eip=0x7c00，刚进入bootloader时，最先执行的操作分别为关闭中断，清楚EFLAGS的DF位以及将ax，ds，es，ss寄存器初始化为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">.code16                                             # Assemble for 16-bit mode</span><br><span class="line">    cli                                             # Disable interrupts</span><br><span class="line">    cld                                             # String operations increment</span><br><span class="line"></span><br><span class="line">    # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">    xorw %ax, %ax                                   # Segment number zero</span><br><span class="line">    movw %ax, %ds                                   # -&gt; Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; Extra Segment</span><br><span class="line">    movw %ax, %ss                                   # -&gt; Stack Segment</span><br></pre></td></tr></table></figure>

<p>接下来为了使CPU进入保护模式后充分使用32位的寻址能力，需要开启A20，关闭“回卷”机制；</p>
<blockquote>
<p><strong>什么是“回卷”机制？</strong></p>
<p>Intel早期的8086 CPU提供了20根地址线，但是8086数据处理位宽位为16位，无法直接寻址1MB的内存空间，所以8086提供了段地址加偏移地址的地址转换机制。</p>
<p>PC机的寻址结构为segment:offset，segment和ofset都是16位寄存器，最大值为0x0ffffh，换算成物理地址是将segement左移4位，再加上offset，所以segment:offset能表示的最大寻址空间为<code>0x10ffefh</code>，为1088KB，超过20位地址线【1024KB=1MB】的内存，会发生“回卷”（不会发生异常）</p>
</blockquote>
<p>下一代Intel 80286 CPU的PC AT计算机系统提供了24根地址线，如果遇到寻址超过1MB的情况，系统不再“回卷”，为了保持向下兼容性，PC AT计算机系统上加了硬件逻辑，来模仿回绕特征，于是出现了<code>A20 Gate</code></p>
<blockquote>
<p>方法为将A20地址线的打开（使能）和关闭（屏蔽/禁止）与键盘控制器8042用逻辑AND连接起来。</p>
<p>一开始A20是被屏蔽的（总为0），直到系统软件通过一定的I/O操作去打开它。很显然，在实模式下要访问buffer，这个开关必须打开。</p>
<p>在保护模式下，由于使用了32位地址线，A20恒为0，则系统只能访问奇数兆内存：<code>0-1M, 2-3M, 4-5M....</code>,这样无法有效访问所有可用内存，所以在保护模式下，这个开关也必须打开</p>
</blockquote>
<p>在保护模式下，为了使能所有地址位的寻址能力，需要开启A20地址线控制，即需要通过向键盘控制器8042发送一个命令来完成。8042会将它的某个输出引脚的输出置高电平，作为A20地址线控制的输入，一旦设置成功，内存将不会再被<strong>绕回（memory wrapping）</strong>，这样就可以寻址整个80286 16M内存，或者寻址80386级别机器的所有4G内存</p>
<p>这个过程主要分为等待8042控制器<code>Input Buffer</code>为空，发送P2命令到<code>Input Buffer</code>，等待<code>Input Buffer</code>为空，将P2得到的第二个位（A20选通）置为1，写回<code>Input Buffer</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在开启A20之前，BIOS还做了很多事:关中断、清除方向标志，给各个数据段清零。</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">.code16                 # Assemble for 16-bit mode</span><br><span class="line">    cli                 # Disable interrupts</span><br><span class="line">    cld                 # String operations increment --&gt; 操作「方向标志位DF」, DF&#x3D;0:向高地址加；DF&#x3D;1:向低地址减小</span><br><span class="line"></span><br><span class="line">    xorw %ax, %ax       # Segment number zero</span><br><span class="line">    movw %ax, %ds       # -&gt; Data Segment</span><br><span class="line">    movw %ax, %es       # -&gt; Extra Segment</span><br><span class="line">    movw %ax, %ss       # -&gt; Stack Segment</span><br><span class="line"></span><br><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al               # 等待8042键盘控制器不忙</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al             # 发送写8042输出端口的指令 </span><br><span class="line">    outb %al, $0x64             </span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al              # 等待8042键盘控制器不忙，inb 从I&#x2F;O端口读取一个字节</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al              # 打开A20</span><br><span class="line">    outb %al, $0x60 						 # 从I&#x2F;O端口写入一个字 </span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>cli</code>禁止中断发生，<code>stl</code>允许中断发生，这两个指令只能在内核模式下执行，不能在用户模式下执行，在内核模式下执行时，应该尽可能快的恢复中断，如果长时间处于<code>cli</code>下，系统会十分不稳定</p>
</li>
<li><p>如果过程中需要改变段寄存器SS和SP，必须禁止中断，当改变完成后再恢复中断</p>
</li>
</ul>
<hr>
<h3 id="3-2-初始化GDT表"><a href="#3-2-初始化GDT表" class="headerlink" title="3.2 初始化GDT表"></a>3.2 初始化GDT表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                          # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                                     # null seg</span><br><span class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel</span><br><span class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">    .word 0x17                                      # sizeof(gdt) - 1</span><br><span class="line">    .long gdt     </span><br></pre></td></tr></table></figure>

<blockquote>
<p>把gdt表的起始位置和limit装入GDTR寄存器</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lgdt gdtdesc									# 将gdt表的起始位置和limit装入GDTR Reg中</span><br><span class="line">movl %eax, %cr0								# 开启保护模式</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lgdt m16&amp;32</code>：表示将m加载到GDTR，LGDT用于加载全局描述符表格寄存器。相对应的为<code>LIDT:加载中断描述符表格寄存器</code>，为将m加载到IDTR</li>
</ul>
<hr>
<h3 id="3-3-如何使能-amp-进入保护模式"><a href="#3-3-如何使能-amp-进入保护模式" class="headerlink" title="3.3 如何使能&amp;进入保护模式"></a>3.3 如何使能&amp;进入保护模式</h3><p>在A20开启，<code>lgdt gdtdesc</code>载入GDTR后，只需要将CR0寄存器的PE位置设为1，即可从实模式切换到保护模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl %cr0, %eax</span><br><span class="line">orl $CR0_PE_ON, %eax</span><br><span class="line">movl %eax, %cr0</span><br></pre></td></tr></table></figure>

<p>后使用一个长跳转指令，将cs修改为32位段寄存器，及跳转到protcseg（32位入口），此时CPU进入32位模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ljmp $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure>

<p>接下来设置<code>ds, es, fs, gs, ss</code>这些段寄存器，初始化栈的frame pointer &amp; stack pointer，后<code>call bootmain</code>，加载os内核，在这里，bootloader实现了从实模式进入到保护模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.code32                                             # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br><span class="line">    # Set up the protected-mode data segment registers</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line"></span><br><span class="line">    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    movl $start, %esp</span><br><span class="line">    call bootmain</span><br><span class="line"></span><br><span class="line">    # If bootmain returns (it shouldn&#39;t), loop.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="练习4-分析bootloader加载ELF格式的过程"><a href="#练习4-分析bootloader加载ELF格式的过程" class="headerlink" title="练习4:分析bootloader加载ELF格式的过程"></a>练习4:分析bootloader加载ELF格式的过程</h2><ul>
<li>bootloader如何读取硬盘扇区</li>
<li>bootloader如何加载ELF格式的OS</li>
</ul>
<p>参考资料：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://objectkuan.gitbooks.io/ucore-docs/content/lab1/lab1_3_2_3_dist_accessing.html">硬盘访问概述</a></p>
<blockquote>
<p>IDE：Integrated Drive Electronics<strong>「电子集成驱动器」</strong></p>
</blockquote>
</li>
<li><p><a target="_blank" rel="noopener" href="https://objectkuan.gitbooks.io/ucore-docs/content/lab1/lab1_3_2_4_elf.html">ELF文件格式概述</a></p>
</li>
</ul>
<h3 id="4-1-bootloader读取硬盘扇区"><a href="#4-1-bootloader读取硬盘扇区" class="headerlink" title="4.1 bootloader读取硬盘扇区"></a>4.1 bootloader读取硬盘扇区</h3><ol>
<li>先为<code>waitdisk.c</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitdisk</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">    <span class="comment">/*do nothing*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：连续不断的从0x1F7地址读取磁盘的状态，直到磁盘不忙为止</p>
<ol start="2">
<li>再到<code>readsect.c</code></li>
</ol>
<blockquote>
<p>基本功能：读取一个磁盘扇区</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">readsect(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno) &#123;</span><br><span class="line">    waitdisk(); <span class="comment">// 等待磁盘到不忙为止</span></span><br><span class="line"></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);             <span class="comment">// 往0X1F2地址中写入要读取的扇区数，由于此处需要读一个扇区，因此参数为1</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>); <span class="comment">// 输入LBA参数的0...7位；</span></span><br><span class="line">    outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>); <span class="comment">// 输入LBA参数的8-15位；</span></span><br><span class="line">    outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>); <span class="comment">// 输入LBA参数的16-23位；</span></span><br><span class="line">    outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>); <span class="comment">// 输入LBA参数的24-27位（对应到0-3位），第四位为0表示从主盘读取，其余位被强制置为1；</span></span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);                      <span class="comment">// 向磁盘发出读命令0x20</span></span><br><span class="line"></span><br><span class="line">    waitdisk(); <span class="comment">// 等待磁盘直到不忙</span></span><br><span class="line"></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>); <span class="comment">// 从数据端口0x1F0读取数据，除以4是因为此处是以4个字节为单位的，这个从指令是以l(long)结尾这点可以推测出来；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读取磁盘扇区过程的总结</strong></p>
<ol>
<li>等待磁盘直到不忙</li>
<li>往<strong>0x1F2到0x1F6</strong>中设置读取扇区需要的参数，包括<strong>读取扇区的数量及LBA参数</strong></li>
<li>往0x1F7端口发送读命令</li>
<li>等待磁盘完成读取操作</li>
<li>从数据端口0x1F0读取数据到指定内存中</li>
</ol>
<p>此外，还有<code>readseg</code>函数来读取磁盘磁盘，其功能为将<code>readsect</code>进一步封装，提供从磁盘第二个扇区起<code>offset</code>个位置处，读取<code>count</code>个字节到指定内存中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从设备中读count个字节到va这个地址，offset是指想读的位置距离开始的偏移</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">readseg(<span class="keyword">uintptr_t</span> va, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset) &#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = va + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算当前偏移在那个扇区的位置，并且让va地址向前偏移这些字节，</span></span><br><span class="line">    <span class="comment">//然后读完之后，用户开始传入的地址va的内容就是偏移所在内容</span></span><br><span class="line">    va -= offset % SECTSIZE;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// translate from btyes to sectors; kernel starts at sector 1</span></span><br><span class="line">    <span class="keyword">uint32_t</span> secno = (offset/ SECTSIZE) +<span class="number">1</span> ;    <span class="comment">//计算偏于所在的扇区，kernel是在起始就是第一个扇区</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno++) (</span><br><span class="line">    readsect((<span class="keyword">void</span> *)va, secno);</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-bootloader加载ELF的os"><a href="#4-2-bootloader加载ELF的os" class="headerlink" title="4.2 bootloader加载ELF的os"></a>4.2 bootloader加载ELF的os</h3><ol>
<li>加载<code>ELF</code>格式OS</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从磁盘第一个扇区（第零个扇区为<code>bootloader</code>）中读取<code>OS kernel</code>最开始的4KB代码，然后判断其最开始四个字节是否等于指定的<strong>ELF_MAGIC</strong>，来判断<strong>ELF Header</strong>是否合法</p>
<ol start="2">
<li>获取<strong>proghdr【program header】</strong>表的位置，以及<strong>该表的入口数目</strong>，后遍历该表的每一项，并从每一个<code>proghdr</code>中获取到段应该被加载到内存中的位置（<code>Load Address</code>，虚拟地址），以及段的大小。之后再调用<code>readseg</code>函数将每一个段加载到内存中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line">ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">    readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>bootloader</code>所要完成的最后一个步骤即从<strong>ELF header中查询OS kernel的入口地址</strong>，然后使用函数调用的方式跳转到该地址</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br></pre></td></tr></table></figure>

<h2 id="练习5-实现函数调用堆栈跟踪函数"><a href="#练习5-实现函数调用堆栈跟踪函数" class="headerlink" title="练习5: 实现函数调用堆栈跟踪函数"></a>练习5: 实现函数调用堆栈跟踪函数</h2><ul>
<li>需要在lab1中完成<code>kdebug.c</code>中函数<code>print_stackframe</code>的实现，可以通过函数<code>print_stackframe</code>来跟踪函数调用堆栈中记录的返回地址</li>
</ul>
<p><strong>补充知识</strong>：<code>bootloader</code>通过读取硬盘扇区把<code>ucore</code>在系统加载到内存后，就跳转到<code>ucore os</code>在内存中的入口位置（<code>kern/init.c</code>中<code>kern_init</code>函数的起始地址），这样ucore就能接管整个控制权</p>
<h3 id="5-1-函数堆栈"><a href="#5-1-函数堆栈" class="headerlink" title="5.1 函数堆栈"></a>5.1 函数堆栈</h3><p><strong>调用栈</strong>最重要的两点：<strong>栈的结构</strong>和<strong>EBP寄存器的作用</strong></p>
<p>一个函数调用动作可以分解为：零到多个PUSH指令（用于参数入栈），一个CALL指令「CALL指令内部还添加了一个<strong>返回地址（即CALL指令下一条指令的地址）</strong>」。几乎所有complier都会在每个函数体之前插入类似如下的汇编指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushl		%ebp</span><br><span class="line">movl		%esp, %ebp</span><br></pre></td></tr></table></figure>

<p>在程序执行到一个函数的实际指令前，已经有以下数据顺序入栈：参数、返回地址、EBP寄存器，得到如下栈结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+|	栈底方向     【高位地址】</span><br><span class="line"> |    ...</span><br><span class="line"> |    ...</span><br><span class="line"> | 	 参数3</span><br><span class="line"> |   参数2</span><br><span class="line"> |   参数1</span><br><span class="line"> |  返回地址</span><br><span class="line"> |	上一层[ebp]</span><br><span class="line"> |	局部变量     【低位地址】</span><br></pre></td></tr></table></figure>

<p>这两条汇编指令的含义是：将ebp寄存器入栈，然后将栈顶指针esp赋值给esp</p>
<p>“Mov ebp esp”这条指令看上去是用esp赋值给ebp，其实不然，因为给ebp赋值之前，原ebp值已经被压栈（位于栈顶），而新的ebp又恰恰指向栈顶，此时ebp寄存器就已经处于一个非常重要的地位，该寄存器中存储着栈中的一个地址（原ebp入栈后的栈顶），从该地址为基准，向上（栈底方向）能获取返回地址、参数值，向下（栈顶方向）能获取函数局部变量值，而该地址处又存储着上一层函数调用时的ebp值。</p>
<p>一般来说，<code>ss:[ebp+4]</code>作为返回地址，<code>ss:[ebp+8]</code>处为第一个参数值（最后一个入栈的参数值，此处假设其占用4字节内存），<code>ss:[ebp-4]</code>处为第一个局部变量，<code>ss:[ebp]</code>处为上一层<code>ebp</code>值。由于<code>ebp</code>中的地址处总是“上一层函数调用时的ebp值”，而在每一层函数调用中，都能通过当时的<code>ebp值</code>向上（栈底方向）能获取返回地址、参数值，向下（栈底方向）能获取函数局部变量值，如此形成递归，直至到达栈底，这就是函数调用栈。</p>
<h3 id="5-2-前提知识"><a href="#5-2-前提知识" class="headerlink" title="5.2 前提知识"></a>5.2 前提知识</h3><p>栈相关的寄存器有两个，<code>ebp（基址寄存器）</code>和<code>esp（栈指针寄存器）</code>，栈的增长方向由高到低</p>
<p><code>eip</code>为程序指令指针，为当前程序运行的指令</p>
<p>举例，main函数在调用<code>sum(int a, int b)</code>时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+|	参数b  | -高地址</span><br><span class="line"> |	参数a</span><br><span class="line"> |	sum函数下一条命令的地址</span><br><span class="line"> |	main函数栈的基址</span><br><span class="line">-|	----	|- ebp【低地址】</span><br></pre></td></tr></table></figure>

<p>此时，ebp是sum函数栈的基址，而后eip内是sum函数中的第一条指令</p>
<p>sum函数执行完之后，sum函数栈的内容全部出栈，然后ebp重新变成 main函数的函数栈基址,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ebp = *((<span class="keyword">uint_t</span>*) ebp)</span><br><span class="line">eip = *((<span class="keyword">uint_t</span>*)ebp+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>以上为sum函数之后的指令的地址，然后函数参数出栈</p>
<h3 id="5-3-插入代码"><a href="#5-3-插入代码" class="headerlink" title="5.3 插入代码"></a>5.3 插入代码</h3><ul>
<li><code>cprintf</code>与printf的区别</li>
</ul>
<ol>
<li>cprintf函数用于向当前窗口输出数据，printf为标准输出，可以完全不知道其需要输出的对象，只是以标准的文本流式输出；cprintf与终端相关，要用到一些系统平台，硬件设备相关的特性，所以可以有颜色等很多东西来选择，但同时也削弱了移植性，所以cprintf是非标准的，cprintf中的c代表console，即控制台。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///kern/debug/kdebug.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stackframe</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> t_ebp = read_ebp();</span><br><span class="line">    <span class="keyword">uint32_t</span> t_eip = read_eip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; STACKFRAME_DEPTH &amp;&amp; t_ebp!=<span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;ebp=%08x, eip=%08x,  args:&quot;</span>, t_ebp, t_eip);</span><br><span class="line">        <span class="keyword">for</span>( j =<span class="number">0</span> ; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cprintf(<span class="string">&quot; %08x &quot;</span>, *((<span class="keyword">uint32_t</span>*)t_ebp+<span class="number">2</span>+j));</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        print_debuginfo(t_eip<span class="number">-1</span>);</span><br><span class="line">        t_eip = *((<span class="keyword">uint32_t</span>*)t_ebp+<span class="number">4</span>);</span><br><span class="line">        t_ebp = *((<span class="keyword">uint32_t</span>*)t_ebp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据kdebug.c的要求来写，在这个函数下方有提示的～！</p>
</blockquote>
<h3 id="5-4-最后一行输出分析"><a href="#5-4-最后一行输出分析" class="headerlink" title="5.4 最后一行输出分析"></a>5.4 最后一行输出分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ebp:0x00007bf8 eip:0x00007d6e args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8</span><br><span class="line">    &lt;unknow&gt;: -- 0x00007d6d --</span><br></pre></td></tr></table></figure>

<p>打印出的ebp是第一个被调用函数的栈帧的<code>base pointer</code>，<code>eip</code>是在该栈帧对应函数中调用下一个栈帧对应函数的指令的下一条指令的地址<code>（return address）</code>， 而args是传递给这第一个被调用的函数的参数</p>
<p>之后的<code>&lt;unknow&gt;: -- 0x00007d6d    </code>则是bootmain函数内调用<strong>OS kernel</strong>入口函数该指令的地址</p>
<h2 id="练习6-完善中断初始化和处理"><a href="#练习6-完善中断初始化和处理" class="headerlink" title="练习6: 完善中断初始化和处理"></a>练习6: 完善中断初始化和处理</h2><ul>
<li>IDT（可以简称为保护模式下的中断向量表）中一个表项占多少字节，其中哪几位代表中断处理代码的入口</li>
<li>完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，一次对所有中断入口进行初始化，使用mmu.h中的SETGATE宏，填充IDT数组内容，每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可</li>
<li>完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分天蝎trap函数中处理时钟中断的部分，使os每遇到100次时钟中断后，调用print_ticks子程序，想屏幕上打印一行“100ticks”</li>
</ul>
<h3 id="6-1-中断与异常"><a href="#6-1-中断与异常" class="headerlink" title="6.1 中断与异常"></a>6.1 中断与异常</h3><p>os需要对计算机系统中的各种外设进行管理，这就需要cpu和外设能够相互通信才行，一般外设的速度远慢于cpu的速度。</p>
<p>如果让os通过cpu“主动关心”外设的事情，采用通常的轮询机制，会很浪费CPU的资源。</p>
<p>因此需要os和CPU能够一起提供某种机制，让<strong>外设在需要OS处理外设相关事件的时候，能够“主动通知”OS，通过中断机制来中断OS和应用的正常执行</strong></p>
<p>os中，有三类中断事件：</p>
<ol>
<li><strong>异步中断【外部中断】：</strong> 简称<strong>中断</strong>，由CPU外部设备引起的外部事件，<strong>产生的时刻不确定</strong>： I/O中断、时钟中断、控制台中断等</li>
<li><strong>同步中断【内部中断】：</strong> 简称<strong>异常</strong>，发生在CPU执行指令期间检测到不正常的或者非法的条件（如除零错误、地址访问越界）所引起的内部事件</li>
<li><strong>陷入中断【软中断】：</strong> 简称trap，即在程序中使用请求系统服务的系统调用而引发的事件，系统调用sys call也称trap</li>
</ol>
<p>当CPU收到<strong>中断（通过8259A完成）</strong>或者异常事件时，他会暂停执行当前的程序或任务，通过一定的机制跳转到负责处理这个信号的相关处理例程中，在完成对这个事件的处理后再跳回到刚才被打断的程序或任务中。</p>
<p><strong>中断向量&amp;中断服务例程主要由IDT负责</strong>，os在IDT中设置好各种中断向量对应的中断描述符，等待CPU在产生中断后查询对应中断服务例程的起始地址，而IDT本身的起始地址保存在IDTR寄存器中</p>
<ol>
<li><p><strong>IDT：</strong> IDT将每个中断或异常编号和一个只想中断服务例程的描述符联系起来。同GDT一样，IDT是一个8字节的描述符数组，但是IDT第一项可以包含一个描述符，CPU把中断（异常）乘8作为IDT的索引，IDT可以位于内存的任意位置，CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址，指令LIDT和SIDT来操作IDTR：</p>
<ul>
<li><strong>LIDT【Load IDT Register】</strong>指令：使用一个包含线性地址基址和界限的内存操作数来加载LDT，os创建IDT时需要执行它来设定IDT的起始地址，这条指令只能在<strong>特权级0</strong>执行</li>
<li><strong>SIDT【Store IDT Register】</strong>指令：拷贝IDTR的基址和界限部分到一个内存地址，这个指令可以在任意特权级执行</li>
</ul>
<p>在保护模式下，最多会存在256个中断/异常向量，范围【0， 31】内的32个向量被异常Exceptuion和NMI使用，但当前并非所有这32个向量都已经被使用，还有几个当前没有被使用的，这些没有被使用的向量被保留给用户定义的interrupts。intel没有定义，也没有保留这些interuppts，用户可以将它们用作外部I/O设备中断，或者系统调用等</p>
</li>
<li><p><strong>IDT Gate Descriptors</strong></p>
</li>
</ol>
<p>interrupts/exceptions应该使用interrupt gate和trap gate，唯一区别在于：当调用interrupt Gate时，interrupt会被CPU自动禁止；而当调用Trap Gate时，CPU不会去禁止或打开中断，而是保留它原来的样子</p>
<blockquote>
<p><strong>“自动禁止”</strong>：指的是CPU跳转到interrput gate里的地址时，将EFLAGS保存到栈上之后，清楚EFLAGS里的IF位，以避免重复触发中断。</p>
<ol>
<li>在中断处理例程里，os可以将EFLAGS里的IF设上，从而允许<strong>嵌套中断</strong>，但是必须在这之前做好处理嵌套中断的必要准备，如保存必要的寄存器等</li>
<li>在ucore中访问Trap Gate的目的是为了实现系统调用，用户进程在正常执行中是不能禁止中断的，当它发出系统调用后，将通过Trap Gate完成从用户态的用户进程进入核心态的OS kernel，如果在到达OS kernel后禁止EFLAGS里的IF位，第一没意义，第二还会导致某些中断得不到及时响应，所以调用Trap Gate时，CPU不会去禁止中断</li>
</ol>
<p>总之，<code>interrupt gate</code>和<code>trap gate</code>之间没有优先级之分，只是cpu在处理中断时有不同的方法，供OS在实现时根据需要进行选择</p>
</blockquote>
<p>IDT中，包含了如下3种Descriptor：</p>
<ul>
<li>Task-gate Descriptor【这里没有用到】</li>
<li>Interrupt-gate Descriptor【<strong>中断</strong>方式】</li>
<li>Trap-gate Descriptor【<strong>系统调用</strong>用到】</li>
</ul>
<hr>
<h3 id="6-2-IDT的定义"><a href="#6-2-IDT的定义" class="headerlink" title="6.2 IDT的定义"></a>6.2 IDT的定义</h3><p>问：IDT中一个表项占多少字节，其中哪几位表示中断处理代码的入口？</p>
<ul>
<li>IDT中每一个表项均占<strong>8个字节【32位】</strong></li>
<li>其中最开始2个字节和最末尾2个字节定义了offset，第16-31位定义了处理代码入口地址的<strong>段选择子【段选择符】</strong>，使用他们在GDT中查找相应段的base address，加上offset即为中断处理代码的入口</li>
</ul>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210407194442350.png" alt="image-20210407194442350" style="zoom:50%;">



<ul>
<li>8-12位表示门类型<code>0DXXX</code>：三类门：中断门，陷阱门，任务门</li>
</ul>
<h3 id="6-3-完善trap-c"><a href="#6-3-完善trap-c" class="headerlink" title="6.3 完善trap.c"></a>6.3 完善trap.c</h3><p>在idt_init函数中，依次对所有中断入口进行初始化，使用mmu.h中的SETGATE宏，填充idt数组内容，每个中断的入口由<code>tools/vectors.c</code>生成</p>
<h4 id="6-3-1-中断再次了解"><a href="#6-3-1-中断再次了解" class="headerlink" title="6.3.1 中断再次了解"></a>6.3.1 中断再次了解</h4><ol>
<li><strong>异步中断：</strong> 外设事件引起</li>
<li><strong>同步中断：</strong> 内部中断，即异常</li>
<li><strong>陷入中断：</strong> 软中断，请求系统服务的系统调用而引发的事件</li>
</ol>
<blockquote>
<p>中断描述符表将每个中断或异常的编号和一个指向中断服务例程的描述符联系起来</p>
</blockquote>
<h4 id="6-3-2-mmu-h中的SETGATE宏"><a href="#6-3-2-mmu-h中的SETGATE宏" class="headerlink" title="6.3.2 mmu.h中的SETGATE宏"></a>6.3.2 mmu.h中的SETGATE宏</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl) &#123;            \</span></span><br><span class="line">    (gate).gd_off_15_0 = (<span class="keyword">uint32_t</span>)(off) &amp; <span class="number">0xffff</span>;        \</span><br><span class="line">    (gate).gd_ss = (sel);                                \</span><br><span class="line">    (gate).gd_args = <span class="number">0</span>;                                    \</span><br><span class="line">    (gate).gd_rsv1 = <span class="number">0</span>;                                    \</span><br><span class="line">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \</span><br><span class="line">    (gate).gd_s = <span class="number">0</span>;                                    \</span><br><span class="line">    (gate).gd_dpl = (dpl);                                \</span><br><span class="line">    (gate).gd_p = <span class="number">1</span>;                                    \</span><br><span class="line">    (gate).gd_off_31_16 = (<span class="keyword">uint32_t</span>)(off) &gt;&gt; <span class="number">16</span>;        \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上用于<strong>中断/陷阱门的描述表</strong>：</p>
<ul>
<li><code>istrap:</code> istrap只有两种状态，1代表陷阱门，0代表中断门</li>
<li><code>sel:</code> sel表示用于中断/陷阱处理程序的<strong>代码段选择器</strong>，即处理中断/陷阱需要在内核段中执行，还是在用户段中执行</li>
<li><code>off:</code> off表示中断/陷阱处理程序的代码段偏移地址</li>
<li><code>dpl:</code> dpl用于表示描述符的特权级别，包括内核权限以及用户权限。ucore中应用程序处于特权级3，内核态特权级为0</li>
</ul>
<hr>
<p>除了**系统调用中断(T_SYSCALL)**外，其他中断均使用中断门描述符，权限为内核态权限；而系统调用中断使用异常，权限为陷阱门描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">idt_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">// 声明_vector[]对应IDT中的256个中断符，256个中断符的入口在tools/vector.c中定义</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[];</span><br><span class="line">  <span class="comment">/*这里的for循环使用了mmu.h中的SETGATE宏定义函数，对中断门idt[i]初始化*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt)/<span class="keyword">sizeof</span>(struct gatedesc); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      	<span class="comment">//0-中断门，GO_KTEXT-内核代码段的起始地址，_vectors[i]存放偏移地址</span></span><br><span class="line">        <span class="comment">//0-DPL_KERNEL表示的为内核权限</span></span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i]; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *下述代码表示的是由用户态--&gt;核心态的中断表的初始化</span></span><br><span class="line"><span class="comment">  *DPL_USER表示的为用户权限</span></span><br><span class="line"><span class="comment">  *T_SYSCALL在trap.h中定义</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KTEXT, __vectors[T_SYSCALL]; <span class="number">3</span>);</span><br><span class="line">  <span class="comment">//加载idt中断描述符表，将&amp;idt_pd的首地址加载到IDTR中</span></span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-4-调用print-ticks子程序"><a href="#6-4-调用print-ticks子程序" class="headerlink" title="6.4 调用print_ticks子程序"></a>6.4 调用print_ticks子程序</h3><p>问题：使os每遇到100次时钟中断后，调用print_ticks子程序，在屏幕上打印<code>100 ticks</code></p>
<p>上述问题中已经完成了对idt的init操作，此时在clock.c中的全局变量ticks开始统计，在<code>kern\trap\trap.c</code>中找到计时中断，当统计到100次时，调用<code>print_ticks()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET+IRQ_TIMER:</span><br><span class="line">    ticks++;</span><br><span class="line">    <span class="keyword">if</span> (ticks % TICK_NUM == <span class="number">0</span>) &#123; <span class="comment">//TICK_NUM在最上方已经由#define定义了</span></span><br><span class="line">        print_ticks();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/uCore/" rel="tag">uCore</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-uCore/Lab 0"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/04/uCore/Lab%200/"
    >uCore Lab 0</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/04/uCore/Lab%200/" class="article-date">
  <time datetime="2021-04-04T04:18:50.260Z" itemprop="datePublished">2021-04-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/uCore/">uCore</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <script src="/assets/js/APlayer.min.js"> </script><h1 id="Lab-0"><a href="#Lab-0" class="headerlink" title="Lab 0"></a>Lab 0</h1><h2 id="0-1-Intel-80386-处理器硬件"><a href="#0-1-Intel-80386-处理器硬件" class="headerlink" title="0.1 Intel 80386 处理器硬件"></a>0.1 Intel 80386 处理器硬件</h2><h3 id="0-1-1-80386-运行模式"><a href="#0-1-1-80386-运行模式" class="headerlink" title="0.1.1 80386 运行模式"></a>0.1.1 80386 运行模式</h3><p>80386四种模式：实模式、保护模式、SMM模式和虚拟8086模式</p>
<p>ucore中涉及的是前两种：实模式和保护模式</p>
<ul>
<li><strong>实模式</strong></li>
</ul>
<p>实模式将整个物理内存堪称分段的区域，程序代码和数据位于不同区域，os和用户程序没有区别对待，并且每一个指针都是指向实际的物理地址。</p>
<p>这样，当用户程序的一个指针如果指向了os区域或其他用户程序区域，后果是灾难性的</p>
<ul>
<li><strong>保护模式</strong></li>
</ul>
<p><strong>主要目的</strong>是确保应用程序无法对操作系统进行破坏。</p>
<p>实际上， 80386通过在实模式下初始化控制寄存器以及页表，后通过设置CR0寄存器将其中的<strong>保护模式的使能位置位</strong>，从而进入到80386的保护模式。当80386工作在保护模式下的时候，其所有的32根地址线都可供寻址，物理寻址空间高达4GB。</p>
<p>在保护模式下，支持内存分页机制，并且支持优先级机制，不同的程序可以运行在不同的特权级上，特权级一共分0～3四个级别，os运行在最高的<strong>特权级0</strong>上</p>
<h3 id="0-1-2-80386内存架构"><a href="#0-1-2-80386内存架构" class="headerlink" title="0.1.2 80386内存架构"></a>0.1.2 80386内存架构</h3><p>80386时32位处理器，可以寻址的物理内存地址空间为$2^{32} = 4G$字节，在ucore中，需要用到三个地址空间的概念：物理地址、线性地址和逻辑地址</p>
<p><strong>物理内存地址空间</strong>： 为处理器提交到总线上用于访问计算机系统中的内存和外设的最终地址，一个计算机系统中只有一个物理地址空间</p>
<p><strong>线性地址空间：</strong> 为80386处理器通过段（Segment）机制控制下形成的地址空间，在os的管理下，每个运行的应用程序都有相对独立的一个或多个内存空间段，每个段有各自的起始地址和长度属性，大小不固定，这样能让多个运行的应用程序之间相互隔离，实现对地址空间的保护</p>
<p>在os完成对80386处理器段机制的<strong>初始化和配置</strong>（需要os通过<strong>特定的指令和操作间里全局描述符表，完成虚拟地址与线性地址的映射关系</strong>）后，80386处理器的段管理功能单元把虚拟地址转换成线性地址。</p>
<p>相对而言，段机制对<strong>大量应用程序分散地使用大内存</strong>的支持能力较弱，所以intel公司又加入了页机制，每个页的大小是固定的（一般是4KB），也可以完成对内存单元的安全保护、隔离，能够有效<strong>支持大量应用程序分散地使用大内存</strong>的情况</p>
<p>在os完成对80386处理器页机制的初始化和配置后，应用程序看到的逻辑地址先被处理器中的段管理功能单元转换为线性地址，然后再通过80386处理器中的页管理功能单元把线性地址转换成物理地址</p>
<blockquote>
<p>页机制和段机制有一定程度的功能重复，intel为了向下兼容等目标，使得这两者一直共存</p>
</blockquote>
<p>上述三种地址的关系为：</p>
<ul>
<li><strong>分段机制启动、分页机制未启动</strong>：逻辑地址–&gt;段机制处理–&gt;线性地址=物理地址</li>
<li><strong>分段机制和分页机制都启动：</strong> 逻辑地址–&gt;<strong>段机制处理</strong>–&gt;线性地址–&gt;页机制处理–&gt;物理地址</li>
</ul>
<h3 id="0-1-3-Intel-80386寄存器"><a href="#0-1-3-Intel-80386寄存器" class="headerlink" title="0.1.3 Intel 80386寄存器"></a>0.1.3 Intel 80386寄存器</h3><p>寄存器有8组，我们一般看到的是四组：通用寄存器【General Register】、段寄存器【Segment Register】、指令指针寄存器【Instruction Pointer】、标志寄存器【Flag Register】</p>
<hr>
<h2 id="0-2-ucore编程方法"><a href="#0-2-ucore编程方法" class="headerlink" title="0.2 ucore编程方法"></a>0.2 ucore编程方法</h2><h3 id="0-2-1-面向对象编程方法"><a href="#0-2-1-面向对象编程方法" class="headerlink" title="0.2.1 面向对象编程方法"></a>0.2.1 面向对象编程方法</h3><p>采用类似C++的接口概念，接口在C语言中，<strong>表现为一组函数指针的集合</strong>，放在C++中，为<strong>虚表</strong>。接口设计的<strong>难点</strong>是如果找出各种<strong>内核子系统的共性访问/操作模式</strong>，从而可以根据访问模式提取出函数指针列表：</p>
<ul>
<li>init：初始化</li>
<li>init_memmap：分析空闲物理内存并初始化管理</li>
<li>alloc_pages: 分配物理页</li>
<li>free_pages：释放物理页</li>
</ul>
<p>其他内存子系统需要与物理内存管理子系统交互时，只需要调用<strong>特定物理内存管理子系统</strong>所采用的pmm_manager数据结构变量中的<strong>函数指针</strong>即可</p>
<h3 id="0-2-2-双向循环链表"><a href="#0-2-2-双向循环链表" class="headerlink" title="0.2.2 双向循环链表"></a>0.2.2 双向循环链表</h3><p>ucore内核中使用了大量的双向循环链表结构来组织数据，包括空闲内存块列表、内存页链表、进程列表、设备链表、文件系统列表等数据组织（在<code>labX/libs/list.h</code>实现），ucore的双向链表结构定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span>	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：list_entry中没有包含data数据与，而是在具体的数据结构中包含链表节点，以lab2的空闲内存块列表为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">list_entry_t</span> free_list;</span><br><span class="line">  	<span class="keyword">unsigned</span> <span class="keyword">int</span> nr_free;					</span><br><span class="line">&#125; <span class="keyword">free_area_t</span>;</span><br></pre></td></tr></table></figure>

<p>有关链表操作函数定义如下：</p>
<ol>
<li>初始化</li>
</ol>
<p>ucore只定义了链表节点，没有专门定义链表头，那么如何建立一个双向循环链表呢？来看list_init这个内联函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_init</span><span class="params">(<span class="keyword">list_entry_t</span> *elm)</span></span>&#123;</span><br><span class="line">	elm-&gt;prev = elm-&gt;next = elm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化的表头使next、prev指针都指向自己，这样就有了一个表示空闲内存块链的空链表。并且我们能够用头指针的next是否指向自己来判断此链表是否为空，这就是内联函数list_empty的实现</p>
<ol start="2">
<li>插入</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__list_add(<span class="keyword">list_entry_t</span> *elm, <span class="keyword">list_entry_t</span> *prev, <span class="keyword">list_enry_t</span> *next)&#123;</span><br><span class="line">	prev-&gt;next = next-&gt;prev = elm;</span><br><span class="line">  elm-&gt;next = next;</span><br><span class="line">  elm-&gt;prev = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>删除</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del</span><span class="params">(<span class="keyword">list_entry_t</span> *listelm)</span> </span>&#123;</span><br><span class="line">	__list_del(listelm-&gt;prev, listelm-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del(<span class="keyword">list_enrty_t</span> *prev, list_entry)&#123;</span><br><span class="line">	prev-&gt;next = next;</span><br><span class="line">	next-&gt;prev = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要确保被删除的节点listelm不再指向链表中的其他节点，可以通过调用list_init函数把listelm的prev、next指针分别指向自身，将节点置为空链状态</p>
<ol start="4">
<li>访问链表节点所在的宿主数据结构</li>
</ol>
<p>list_entry_t通过双向循环链表中仅保存了某特定数据结构中链表节点成员变量的地址，如何通过这个链表节点成员变量访问到它的所有者（即某特定数据结构的变量），Linux提供了针对数据机构XXX的le2XXX的<strong>宏</strong>，其中le，为list entry的简称，是指向数据结构XXX中list_entry_t成员变量的指针，即存储在双向循环链表中的节点地址值，member则是XXX数据类型中包含的链表节点的成员变量。</p>
<p>如：我们要遍历访问空闲块链表中所有节点所在的基于PAGE数据结构的变量，可以采用如下编程方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//free_area为空闲块管理结构，free_area.free_list是空闲块链表头</span></span><br><span class="line"><span class="keyword">free_area_t</span> free_area;</span><br><span class="line"><span class="keyword">list_entry_t</span> *le = &amp;free_area.free_list;	<span class="comment">//le是空闲块链表头指针</span></span><br><span class="line"><span class="keyword">while</span>((le=list_next(le)) != &amp;free_area.free_list) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> le2page(le, page_link);	<span class="comment">//获取节点所在基于Page数据结构的变量</span></span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>le2page宏的使用为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le2page(le, number) to_struct((le), struct Page, member)</span></span><br></pre></td></tr></table></figure>

<p>相比之下，实现用到的to_struct宏和offset_of宏有一些复杂：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the offset of &#x27;member&#x27; relative to the beginning of a struct type */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(type, member) ((size_t)(&amp;((tyoe*)0)-&gt;number))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_struct(ptr, type, number) ((type *)((char *)(ptr) - offsetof((type, member)))</span></span><br></pre></td></tr></table></figure>

<p>这里才用了一个利用gcc编译器技术的技巧，即现求得数据结构的成员变量在本宿主数据结构中的偏移量，然后根据成员变量的地址反过来得出属主数据结构变量的地址</p>
<p>首先来看offsetof宏，size_t最终定义与CPU体系结构相关，本实验都采用Intelx86-32 CPU，因此size_t等价于unsigned int。</p>
<p><code>((type *0)-&gt;member)</code>的设计目的：为了求得数据结构的成员变量在本宿主数据结构中的偏移量，为了达到这个目标，首先将0地址强制“转换”为type数据结构（比如struct Page）的指针，再访问到type数据结构中的member成员（比如Page_link）的地址，即是type数据结构中member成员相对于数据结构变量的偏移量。</p>
<p>在offsetof宏中，这个member成员的地址(即”&amp;((type *)0 -&gt; member)”)实际上为type数据结构中member成员相对于数据结构变量的偏移量。</p>
<p>对于给定一个结构，offsetof(type, number)是一个常量，to_struct宏正是利用这个不变的偏移量来求得链表数据项的变量地址。</p>
<p>再分析一下to_struct宏，可以发现to_struct宏中用到的ptr变量是链表节点的地址，把它减去offsetof宏所获得的<strong>数据结构内偏移量</strong>，即得到了包含链表节点的<strong>属主数据结构变量</strong>的地址</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/uCore/" rel="tag">uCore</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-OS/十 信号量「Semephore」"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/03/25/OS/%E5%8D%81%20%E4%BF%A1%E5%8F%B7%E9%87%8F%E3%80%8CSemephore%E3%80%8D/"
    >Operating System 10 -- 信号量</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/03/25/OS/%E5%8D%81%20%E4%BF%A1%E5%8F%B7%E9%87%8F%E3%80%8CSemephore%E3%80%8D/" class="article-date">
  <time datetime="2021-03-25T13:47:48.823Z" itemprop="datePublished">2021-03-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <script src="/assets/js/APlayer.min.js"> </script><h1 id="十-信号量-「Semaphore」"><a href="#十-信号量-「Semaphore」" class="headerlink" title="十 信号量 「Semaphore」"></a>十 信号量 「Semaphore」</h1><h2 id="10-1-背景"><a href="#10-1-背景" class="headerlink" title="10.1 背景"></a>10.1 背景</h2><ol>
<li><strong>并发问题：竞争条件（竞态条件）</strong><ul>
<li>多程序并发存在很大问题</li>
</ul>
</li>
<li><strong>同步</strong><ul>
<li>多线程共享公共数据的协调执行</li>
<li>包括互斥与条件同步</li>
<li>互斥：在同一时间只有一个线程可以执行临界区</li>
</ul>
</li>
<li><strong>确保同步正确很难？</strong><ul>
<li>需要高层次的编程抽象（如：锁）</li>
<li>从底层硬件支持编译</li>
</ul>
</li>
</ol>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210325172037340.png" alt="image-20210325172037340" style="zoom:50%;">

<h2 id="10-2-信号量"><a href="#10-2-信号量" class="headerlink" title="10.2 信号量"></a>10.2 信号量</h2><p>$Semaphore$是一个同步对象，保持在$0$到指定最大值之间的一个计数值，当线程完成一次对该$Semaphore$对象的等待（$wait$）时，计数值减$1$；当线程完成一次对$ Semaphore$对象的释放（$release$）时，计数值加$1$.</p>
<p>当计数值为$0$，则线程等待该$ Semaphore$对象不再能成功直至$ Semaphore$对象变成$signaled$状态。$ Semaphore$对象的计数值大于$0$时，为$signaled$状态；等于$0$时，为$non-signaled$状态</p>
<p><strong>抽象数据类型</strong></p>
<ul>
<li>一个整型（<strong>sem</strong>【信号量】），两个<strong>原子操作</strong></li>
<li>P<code>[wait()]</code> : <code>sem</code>减1，如果<code>sem&lt;0</code>；等待，否则继续。企图进入临界区段的进程，需要先运行P，当sem大于0时，进程才能获准进入临界区段</li>
<li>V<code>[signal()]</code>:  <code>sem</code>加1，如果<code>sem&lt;=0</code>，意味着当前有进程在等待信号量上面，唤醒一个或多个等待的P。当sem不为负值时，先前被挡住的其他进程，将可获准进入临界区段</li>
</ul>
<p><strong>信号量可以类比于铁路，初始化的时候需要给一个非负数的整数值</strong></p>
<h2 id="10-3-信号量的使用"><a href="#10-3-信号量的使用" class="headerlink" title="10.3 信号量的使用"></a>10.3 信号量的使用</h2><ul>
<li>信号量是<strong>整数</strong></li>
<li>信号量是<strong>被保护</strong>的变量<ul>
<li>初始化完成后，唯一一个改变信号量值的办法是通过<code>P()</code>和<code>V()</code></li>
<li>操作必须是原子</li>
</ul>
</li>
<li><strong>P()能够阻塞</strong>，V()不会阻塞</li>
<li>我们假定信号量是“公平的”<ul>
<li>没有线程被阻塞在P()仍然阻塞如果V()被无限频繁调用（在同一个信号量）</li>
<li>在实践中，FIFO经常被使用</li>
</ul>
</li>
<li><strong>两种类型信号量</strong><ul>
<li><strong>二进制信号量：</strong> 0或1</li>
<li><strong>一般/计数信号量：</strong> 可以取任何非负值</li>
<li>两者相互表现（给定）</li>
</ul>
</li>
<li><strong>信号量可以用在2个方面</strong><ul>
<li>互斥</li>
<li>条件同步（调度约束–一个线程等待另一个线程的事情发生）</li>
</ul>
</li>
</ul>
<h2 id="10-3-信号量使用"><a href="#10-3-信号量使用" class="headerlink" title="10.3 信号量使用"></a>10.3 信号量使用</h2><ul>
<li><p>用<strong>二进制信号量实</strong>现的互斥</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutex = new Semaphore(1);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>一个线程等待另一个线程处理事情</strong></p>
<ul>
<li>比如<strong>生产东西或消费东西</strong></li>
<li>互斥（锁机制）是不够的</li>
</ul>
</li>
<li><p><strong>如：有界缓冲区的生产者 - 消费者问题</strong></p>
<ul>
<li>一个或多个<strong>生产者</strong>产生数据将数据放在一个缓冲区里</li>
<li>单个<strong>消费者</strong>每次从缓冲区取出数据</li>
<li>在任何一个时间<strong>只有一个</strong>生产者或消费者可以访问该缓冲区</li>
</ul>
</li>
</ul>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210325191007542.png" alt="image-20210325191007542" style="zoom:50%;">

<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210325191132809.png" alt="image-20210325191132809" style="zoom:50%;">

<ul>
<li><strong>每个约束用一个单独的信号量</strong><ul>
<li>二进制信号量互斥</li>
<li>一般信号量fullBuffers</li>
<li>一般信号量emptyBuffers</li>
</ul>
</li>
</ul>
<h2 id="10-4-信号量实现"><a href="#10-4-信号量实现" class="headerlink" title="10.4 信号量实现"></a>10.4 信号量实现</h2><ol>
<li><strong>使用硬件原语</strong><ul>
<li>禁用中断</li>
<li>原子指令【Test-and-Set】</li>
</ul>
</li>
<li><strong>类似锁</strong></li>
<li><strong>例如：使用“禁用中断”</strong></li>
</ol>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210325192441087.png" alt="image-20210325192441087" style="zoom:50%;">

<ul>
<li><strong>信号量的双用途</strong><ul>
<li>互斥和条件同步</li>
<li>但等待条件是独立的互斥</li>
</ul>
</li>
</ul>
<p><strong>存在的缺点</strong></p>
<ul>
<li><strong>读/开发代码比较困难</strong></li>
<li><strong>容易出错</strong><ul>
<li>使用的信号量已经被另一个线程占用</li>
<li>忘记释放信号量</li>
</ul>
</li>
<li><strong>不能够处理死锁问题</strong></li>
</ul>
<h2 id="10-5-管程「Monitor」"><a href="#10-5-管程「Monitor」" class="headerlink" title="10.5 管程「Monitor」"></a>10.5 管程「Monitor」</h2><ol>
<li><p>目的：分离互斥和条件同步的关注</p>
</li>
<li><p><strong>什么是管程呢？</strong></p>
<ul>
<li><p><strong>一个锁：</strong> 指定临界区</p>
</li>
<li><p><strong>0或者多个条件变量：</strong> 等待/通知信号量用于管理并发访问共享数据</p>
</li>
</ul>
</li>
<li><p><strong>一般方法</strong></p>
<ul>
<li><strong>收集在对象/模块中的相关共享数据</strong></li>
<li><strong>定义方法来访问共享数据</strong></li>
</ul>
</li>
</ol>
<h2 id="10-6-经典同步问题"><a href="#10-6-经典同步问题" class="headerlink" title="10.6 经典同步问题"></a>10.6 经典同步问题</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-OS/九 同步"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/03/24/OS/%E4%B9%9D%20%E5%90%8C%E6%AD%A5/"
    >Operating System 9 -- 同步</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/03/24/OS/%E4%B9%9D%20%E5%90%8C%E6%AD%A5/" class="article-date">
  <time datetime="2021-03-24T09:31:58.599Z" itemprop="datePublished">2021-03-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <script src="/assets/js/APlayer.min.js"> </script><h1 id="九-同步"><a href="#九-同步" class="headerlink" title="九 同步"></a>九 同步</h1><h2 id="9-1-背景"><a href="#9-1-背景" class="headerlink" title="9.1 背景"></a>9.1 背景</h2><ol>
<li><strong>独立的线程</strong><ul>
<li>不和其他线程共享资源或状态</li>
<li><strong>确定性</strong> ==》输入状态决定结果</li>
<li><strong>可重现</strong> ==》能够重现起始条件，I/O</li>
<li>调度顺序不重要</li>
</ul>
</li>
<li><strong>合作线程</strong><ul>
<li>在多个线程中共享状态</li>
<li>不确定性、不可重现</li>
</ul>
</li>
<li><strong>不确定性</strong>和<strong>不可重现</strong>意味着bug可能是间歇性发生的</li>
</ol>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324171031949.png" alt="image-20210324171031949" style="zoom:50%;">

<p><strong>可能出现的问题</strong></p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324171243129.png" alt="image-20210324171243129" style="zoom:50%;">

<p><strong>但是os要求</strong></p>
<ol>
<li>无论<strong>多个线程的指令序列怎样交替执行，程序都必须正常工作</strong></li>
</ol>
<ul>
<li>多线程程序具有不确定性和不可重现的特点</li>
<li>不经过专门设计，<strong>调试难度很高</strong></li>
</ul>
<ol start="2">
<li><strong>不确定性要求并行程序的正确性</strong></li>
</ol>
<h2 id="9-2-一些概念"><a href="#9-2-一些概念" class="headerlink" title="9.2 一些概念"></a>9.2 一些概念</h2><p><strong>Race Condition【竞态条件】</strong></p>
<ul>
<li>系统缺陷：结果依赖于并发执行或者事件的顺序/时间</li>
<li><strong>如何避免竞态呢？</strong> — 让指令不被打断</li>
</ul>
<p><strong>Atomic Operation【原子操作】</strong></p>
<ul>
<li><strong>原子操作是一次不存在任何中断或者失败的执行</strong><ul>
<li>该执行成功结束|根本没有执行</li>
<li>并且不存在部分执行的状态</li>
</ul>
</li>
<li><strong>实际上操作往往不是原子的</strong><ul>
<li>如<code>A++</code>由3条指令构成</li>
<li>有时单条机器指令也不是原子的：<code>pipeline</code>、<code>super-scalar</code></li>
</ul>
</li>
</ul>
<p><strong>Critical section【临界区】</strong></p>
<p>临界区指进程中一段需要访问共享资源，而当另一个进程处于相应代码区域时不会被执行的代码区域</p>
<p><strong>Mutual exclusion【互斥】</strong></p>
<p>当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源</p>
<p><strong>Dead lock【死锁】</strong></p>
<p>两个或以上的进程，在相互等待完成特定任务，而最终设法将自身任务进行下去</p>
<p><strong>Starvation【饥饿】</strong></p>
<p>一个可执行的进程，被调度器持续忽略，以至于<strong>虽然处于可执行状态而不被执行</strong></p>
<p><strong>忙等待：</strong> 进程等待的时候，是在消耗CPU的时间，这个叫<code>busy waiting</code></p>
<p>于是设置了<strong>临界区</strong>，在任何时候保证只有一个进程在执行，防止变量的出错，且这个一定是原子操作</p>
<h2 id="9-3-临界区「Critical-Section」"><a href="#9-3-临界区「Critical-Section」" class="headerlink" title="9.3 临界区「Critical Section」"></a>9.3 临界区「Critical Section」</h2><p>临界区的特点有：</p>
<ul>
<li><p><strong>互斥：</strong> 同一时间临界区最多存在一个线程</p>
</li>
<li><p><strong>Progress：</strong> 如果一个线程想要进入临界区，那么它最终会成功</p>
</li>
<li><p><strong>有限等待：</strong> 如果一个线程i在入口区，那么在i的请求被接受之前，其他线程进入临界区的时间是有限制的</p>
</li>
<li><p><strong>无忙等待（可选）：</strong> 如果一个进程在等待进入临界区，那么在它可以进入之前会被挂起【避免了消耗CPU资源，减少忙等待】</p>
</li>
</ul>
<p><strong>设计一些方法来对CPU资源进行保护！</strong></p>
<h2 id="9-4-方法1-禁用硬件中断"><a href="#9-4-方法1-禁用硬件中断" class="headerlink" title="9.4 方法1: 禁用硬件中断"></a>9.4 方法1: 禁用硬件中断</h2><ol>
<li><strong>进入和离开临界区的代码</strong><ul>
<li><code>ENTER_CRITICAL_SECTION</code></li>
<li><code>EXIT_CRITICAL_SECTION</code></li>
</ul>
</li>
<li><strong>基本的机制</strong><ul>
<li><strong>禁用中断</strong></li>
<li>软件方法（如Peterson算法）</li>
<li>更高级的抽象</li>
</ul>
</li>
<li>比较不同的机制<ul>
<li>性能：并发级别</li>
</ul>
</li>
</ol>
<p><strong>禁用中断存在的问题</strong></p>
<ol>
<li><strong>一旦中断被禁用，线程就无法被停止</strong><ul>
<li>整个系统都会停下来</li>
<li>可能导致其他线程处于<strong>饥饿状态</strong></li>
</ul>
</li>
<li><strong>要是临界区可以任意长怎么办</strong><ul>
<li>无法限制响应中断所需的时间</li>
</ul>
</li>
<li>所以临界区一般不长，需要注意的是多CPU情况下，是无法解决互斥问题的</li>
</ol>
<h2 id="9-5-方法2-基于软件的解决方法"><a href="#9-5-方法2-基于软件的解决方法" class="headerlink" title="9.5 方法2: 基于软件的解决方法"></a>9.5 方法2: 基于软件的解决方法</h2><img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324194130651.png" alt="image-20210324194130651" style="zoom:50%;">

<p>有四类算法，最主要的是Peterson算法，举个Bakery算法的例子</p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324195541528.png" alt="image-20210324195541528" style="zoom:50%;">

<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324195611394.png" alt="image-20210324195611394" style="zoom:50%;">

<h3 id="9-6-方法3：-更高级的抽象"><a href="#9-6-方法3：-更高级的抽象" class="headerlink" title="9.6 方法3： 更高级的抽象"></a>9.6 方法3： 更高级的抽象</h3><ol>
<li><p><strong>硬件提供了一些原语</strong></p>
<ul>
<li>如中断禁用，原子操作指令等</li>
</ul>
</li>
<li><p><strong>os提供更高级的编程抽象来简化并行编程</strong></p>
<ul>
<li><strong>如锁，信号量</strong>；从硬件原语中构建</li>
</ul>
</li>
<li><p><strong>锁是一个抽象的数据结构</strong></p>
<ul>
<li>一个二进制状态【锁定/解锁】，两种方法</li>
<li><code>Lock::Acquire()</code> - 锁被释放前一直等待，然后等待锁</li>
<li><code>Lock::Release()</code> - 释放锁，唤醒任何等待的进程</li>
</ul>
</li>
<li><p><strong>使用锁来编写临界区</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock_next_pid-&gt;Acquire();</span><br><span class="line">new_pid = next_pid++;</span><br><span class="line">lock_next_pid-&gt;Release();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>大多数现代体系结构都提供特殊的原子操作指令</strong></p>
<ul>
<li>通过特殊的内存访问电路</li>
<li>针对单处理器和多处理器</li>
</ul>
</li>
<li><p><strong><code>Test-and-Set</code> 测试和置位</strong></p>
<ul>
<li>从内存中读取值</li>
<li>测试该值是否为1（然后返回true/false）</li>
<li>内存值设置为1</li>
</ul>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324200740252.png" alt="image-20210324200740252" style="zoom:50%;">

<blockquote>
<p>rv记录寄存器里的值，然后将寄存器的值设为1，返回的是原来寄存器的值（0或1）</p>
</blockquote>
</li>
<li><p><strong>交换「CAS」</strong></p>
<p>交换内存中的两个值</p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324200838108.png" alt="image-20210324200838108" style="zoom:50%;">

</li>
</ol>
<p><strong>缺点：</strong></p>
<ul>
<li>忙等待消耗CPU时间</li>
<li>当进程离开临界区并且多个进程在等待的时候可能导致饥饿</li>
<li><strong>死锁：</strong> <strong>低优先级的进程拥有临界区</strong>并且一个高优先级进程也需求，那么高优先级进程会<strong>获得处理器并等待临界区</strong>。产生了死锁的现象</li>
</ul>
<p>总结一下～</p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324201738602.png" alt="image-20210324201738602" style="zoom:50%;">

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-OS/八 调度"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/03/24/OS/%E5%85%AB%20%E8%B0%83%E5%BA%A6/"
    >Operating System 8 -- 调度</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/03/24/OS/%E5%85%AB%20%E8%B0%83%E5%BA%A6/" class="article-date">
  <time datetime="2021-03-24T02:11:28.778Z" itemprop="datePublished">2021-03-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <script src="/assets/js/APlayer.min.js"> </script><h1 id="八-调度"><a href="#八-调度" class="headerlink" title="八 调度"></a>八 调度</h1><h2 id="8-1-背景"><a href="#8-1-背景" class="headerlink" title="8.1 背景"></a>8.1 背景</h2><ol>
<li><strong>上下文切换</strong><ol>
<li>切换CPU的当前任务，从一个进程/线程到另一个</li>
<li>保存当前进程/线程在PCB/TCP中的执行上下文（CPU状态）</li>
<li>读取下一个进程/线程的上下文</li>
</ol>
</li>
<li><strong>CPU调度</strong><ol>
<li>从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个进程/线程</li>
<li>调度程序：挑选进程/线程的内核函数（通过一些调度策略）</li>
</ol>
</li>
</ol>
<p><strong>那么在进程/线程的生命周期中什么时候进行调度呢？</strong></p>
<hr>
<p><strong>内核运行调度程序的条件（满足一条即可）</strong></p>
<ul>
<li>一个进程从运行状态切换到等待状态</li>
<li>一个进程被终止了</li>
</ul>
<p><strong>不可抢占式</strong>『non-preemptive』</p>
<ul>
<li>调度程序必须等待事件结束</li>
</ul>
<p><strong>可以抢占</strong>『preemptive』</p>
<ul>
<li>调度程序在中断被响应后执行</li>
<li>当前的进程<strong>从运行切换到就绪</strong>，或者一个进程<strong>从等待切换到就绪</strong></li>
<li>当前运行的进程可以被换出</li>
</ul>
<h2 id="8-2-调度原则"><a href="#8-2-调度原则" class="headerlink" title="8.2 调度原则"></a>8.2 调度原则</h2><h3 id="8-2-1-调度策略"><a href="#8-2-1-调度策略" class="headerlink" title="8.2.1 调度策略"></a>8.2.1 调度策略</h3><p>执行模型：程序在CPU突发和I/O中交替</p>
<p><strong>评价指标：</strong></p>
<ol>
<li><strong>CPU使用率：</strong> cpu处于忙状态所占时间的百分比</li>
<li><strong>吞吐量：</strong> 单位时间内<strong>完成的进程数量</strong></li>
<li><strong>周转时间：</strong> 一个进程从初始化到结束，包括所有等待事件所花费的时间</li>
<li><strong>等待时间：</strong> 进程在就绪队列中等待到running的总时间</li>
<li><strong>响应时间：</strong> 从一个请求被提交到产生第一次响应所花费的时间</li>
</ol>
<p><strong>什么是“更快”的服务呢？</strong></p>
<ul>
<li>传输文件是的<strong>高带宽</strong></li>
<li>玩游戏时的<strong>低延迟</strong></li>
<li>这两个因素是独立的</li>
</ul>
<p><strong>和“水管”类比：</strong></p>
<ul>
<li><strong>低延迟：</strong> 喝水的时候想要一打开水龙头水就流出来</li>
<li><strong>高带宽：</strong> 给游泳池充水时希望从水龙头里同时<strong>流出大量的水</strong>，并且不介意是否存在延迟</li>
</ul>
<p><strong>调度算法的提升指标</strong></p>
<ul>
<li><strong>减少响应时间：</strong> 及时处理用户的输出并且尽快将输出提供给用户</li>
<li><strong>减少平均响应时间的变动：</strong> 在交互系统中，可预测性比<strong>高差异低平均</strong>更重要</li>
<li><strong>增加吞吐量：</strong> 1⃣️减少开销（os开销，上下文切换）；2⃣️系统资源的高效利用（CPU、I/O设备）</li>
<li><strong>减少等待时间：</strong> 减少每个进程的等待时间</li>
</ul>
<p><strong>指标提高的表现</strong></p>
<ul>
<li><p>低延迟调度增加了交互式表现【鼠标点的快！】</p>
</li>
<li><p>os需要<strong>保证吞吐量不受影响</strong></p>
</li>
<li><p>吞吐量是os的计算<strong>带宽</strong></p>
</li>
<li><p>响应时间是os的计算<strong>延迟</strong></p>
</li>
<li><p>还需要相对的<strong>公平</strong>，通过调度算法使每个进程享有相同的服务</p>
</li>
</ul>
<h2 id="8-3-调度算法"><a href="#8-3-调度算法" class="headerlink" title="8.3 调度算法"></a>8.3 调度算法</h2><ol>
<li><strong>FCFS「First Come First Served」【先来先服务】</strong></li>
</ol>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324132140786.png" alt="image-20210324132140786" style="zoom:50%;">

<ol start="2">
<li><strong>SPN（SJF） SRT 【Shortest Job First】</strong></li>
</ol>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324132513213.png" alt="image-20210324132513213" style="zoom:50%;">

<blockquote>
<p>SRT可以抢占正在运行的进程，比较的运行中进程的<strong>结束剩余时间</strong>和新进程的<strong>执行时间</strong></p>
</blockquote>
<p><strong>缺点</strong></p>
<ol>
<li>可能导致<strong>饥饿</strong><ul>
<li>连续的短任务流会使长任务饥饿</li>
<li>短任务可用时的任何长任务的CPU时间都会增加平均等待时间</li>
</ul>
</li>
<li><strong>需要预知未来</strong><ul>
<li>如何预估下一个CPU突发的持续时间</li>
<li>简单的解决办法：询问用户</li>
</ul>
</li>
</ol>
<p>通过过去预知未来的算法：</p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324133135071.png" alt="image-20210324133135071" style="zoom:50%;">

<p>来猜测下一个进程的执行时间，实验数据：</p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324133222742.png" alt="image-20210324133222742" style="zoom:50%;">

<ol start="3">
<li>最高响应比优先「HRN」</li>
</ol>
<ul>
<li>在SPN调度的基础上改进</li>
<li>不可抢占</li>
<li>关注进程等待了多长时间</li>
<li>防止无限期推迟</li>
</ul>
<p>$$<br>R = \frac{w+s}{s}<br>$$</p>
<blockquote>
<p>w: waiting time 等待时间。 s: service time 执行时间</p>
</blockquote>
<p>选择R值高的</p>
<ol start="4">
<li>轮询调度算法【<strong>RR Round Robin</strong>】</li>
</ol>
<ul>
<li>在叫做量子（或时间切片）的离散单元中分配处理器</li>
<li>时间片结束时，切换到下一个准备好的进程</li>
</ul>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324133548510.png" alt="image-20210324133548510" style="zoom:50%;">

<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324133758476.png" alt="image-20210324133758476" style="zoom:50%;">

<p><strong>探究时间片大小的影响</strong></p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324133903614.png" alt="image-20210324133903614" style="zoom:50%;">

<p><strong>再次改进：</strong></p>
<ul>
<li>就绪队列划分成独立的队列</li>
</ul>
<blockquote>
<p>前台（交互）， 后台（批处理）</p>
</blockquote>
<ul>
<li>每个队列有自己的调度策略</li>
</ul>
<blockquote>
<p>如前台：RR，后台：FCFS</p>
</blockquote>
<ul>
<li>调度必须在队列间进行<ol>
<li><strong>固定优先级</strong><ul>
<li>先处理前台，再处理后台</li>
<li>可能导致饥饿</li>
</ul>
</li>
<li><strong>时间切片</strong><ul>
<li>每个队列都能得到一个确定的能够调度其进程的CPU总时间</li>
<li>E.g. 80%给使用RR的前台，20%给使用FCFS的后台</li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>于是出现了多级反馈队列</p>
</blockquote>
<ol start="5">
<li><strong>多级反馈队列</strong></li>
</ol>
<ul>
<li>一个进程可以在不同的队列中移动</li>
<li>如：n级优先级-优先级调度在所有级别中，RR在每个级别中</li>
</ul>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324162554607.png" alt="image-20210324162554607" style="zoom:50%;">

<ol start="6">
<li><strong>FFS「Fair File Share」</strong></li>
</ol>
<ul>
<li>一些用户组比其他用户组更重要</li>
<li>保证不重要的组无法垄断资源</li>
<li><strong>未使用的资源</strong>按照每个组所分配的资源的比例来分配</li>
<li>没有达到资源使用率目标的组获得更高的优先级</li>
</ul>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324162905916.png" alt="image-20210324162905916" style="zoom:50%;">

<p><strong>如何评价模型？</strong></p>
<ol>
<li><strong>确定性建模：</strong> 确定一个工作量，然后计算每个算法的表现</li>
<li><strong>队列模型：</strong> 用来处理<strong>随机工作负载</strong>的数学方法</li>
<li><strong>实现/模拟：</strong> 建立一个允许算法运行实际数据的系统，需要很灵活/有一致性</li>
</ol>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324163255535.png" alt="image-20210324163255535" style="zoom:50%;">

<h2 id="8-4-实时调度"><a href="#8-4-实时调度" class="headerlink" title="8.4 实时调度"></a>8.4 实时调度</h2><h3 id="8-4-1-实时系统"><a href="#8-4-1-实时系统" class="headerlink" title="8.4.1 实时系统"></a>8.4.1 实时系统</h3><p><strong>定义：</strong> 正确性依赖于<strong>时间</strong>【real time】和<strong>功能</strong></p>
<p><strong>性能指标：</strong> 1⃣️ 时间约束的及时性「ddl」；2⃣️ 速度和平均性能相对不重要</p>
<p><strong>主要特性：</strong> 时间约束的可预测性</p>
<p><strong>实时分类：</strong> 1⃣️ 硬实时「强实时」：保证规定时间内必须完成任务； 2⃣️ 要求重要的进程的优先级更高，尽量完成，并非必需</p>
<p><strong>如何衡量进程在限定时间内可完成呢？</strong></p>
<p>发起任务–「就绪」–&gt;执行–&gt;不能超过relative ddl的时间间隔</p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324164247351.png" alt="image-20210324164247351" style="zoom:50%;">

<hr>
<ul>
<li><p><strong>硬时限</strong></p>
<ol>
<li>如果错过了ddl，会有严重的后果</li>
<li>必须验证在最坏的情况下也能满足时限【保证确定性】</li>
</ol>
</li>
<li><p><strong>软时限</strong></p>
<ol>
<li>理想情况下，时限应该被最大满足，否则就相应地降低要求</li>
<li>需要尽最大努力去保证</li>
</ol>
<p>设置优先级调度方法来满足ddl要求</p>
</li>
</ul>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324164724307.png" alt="image-20210324164724307" style="zoom:50%;">

<blockquote>
<p>静态：优先级提前设置好           动态：优先级可调整</p>
</blockquote>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324164849527.png" alt="image-20210324164849527" style="zoom:50%;">

<h2 id="8-5-多处理器调度与优先级反转"><a href="#8-5-多处理器调度与优先级反转" class="headerlink" title="8.5 多处理器调度与优先级反转"></a>8.5 多处理器调度与优先级反转</h2><h3 id="8-5-1-多处理器调度"><a href="#8-5-1-多处理器调度" class="headerlink" title="8.5.1 多处理器调度"></a>8.5.1 多处理器调度</h3><ol>
<li>多处理器的CPU调度更加复杂<ul>
<li>多个相同的单处理器组成一个多处理器</li>
<li>优点：负载共享</li>
</ul>
</li>
<li>对称多处理器<ul>
<li>每个处理器运行自己的调度程序</li>
<li>需要在<strong>调度程序中同步</strong></li>
</ul>
</li>
</ol>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324165104306.png" alt="image-20210324165104306" style="zoom:50%;">

<h3 id="8-5-2-优先级反转"><a href="#8-5-2-优先级反转" class="headerlink" title="8.5.2 优先级反转"></a>8.5.2 优先级反转</h3><img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324165159392.png" alt="image-20210324165159392" style="zoom:50%;">

<ul>
<li><strong>优先级天花板：</strong> “资源”的优先级和“所有可以<strong>锁定该资源的任务中优先级最高的那个任务”的优先级相同</strong></li>
<li>除非优先级高于系统中所有被锁定的资源的优先级上限，否则任务尝试执行临界区时会被阻塞</li>
<li>持有<strong>最高优先级上限信号量锁</strong>的任务，会继承被该锁阻塞的任务的优先级</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-OS/七 进程管理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/03/23/OS/%E4%B8%83%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"
    >Operating System 7 -- 进程管理</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/03/23/OS/%E4%B8%83%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2021-03-23T05:38:52.386Z" itemprop="datePublished">2021-03-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <script src="/assets/js/APlayer.min.js"> </script><h1 id="七-进程管理"><a href="#七-进程管理" class="headerlink" title="七 进程管理"></a>七 进程管理</h1><h2 id="7-1-进程「Process」描述"><a href="#7-1-进程「Process」描述" class="headerlink" title="7.1 进程「Process」描述"></a>7.1 进程「Process」描述</h2><h3 id="1-进程的定义"><a href="#1-进程的定义" class="headerlink" title="1. 进程的定义"></a>1. 进程的定义</h3><p>一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程</p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210323132339312.png" alt="image-20210323132339312" style="zoom:50%;">

<p>程序是静态的，操作系统使其动态运行起来</p>
<h3 id="2-进程的组成"><a href="#2-进程的组成" class="headerlink" title="2. 进程的组成"></a>2. 进程的组成</h3><ul>
<li>程序的代码</li>
<li>程序的处理数据</li>
<li>PC「Program Counter」中的值，只是下一条将要运行的指令</li>
<li>一组通用寄存器的当前值，堆、栈</li>
<li>一组系统资源（如打开的文件）</li>
</ul>
<blockquote>
<p> 总之，进程包含<strong>了正在运行的一个程序的所有状态信息</strong></p>
</blockquote>
<p><strong>进程与程序的联系？</strong></p>
<ul>
<li>程序是产生进程的基础</li>
<li>程序的每次运行构成不同的进程</li>
<li>进程是程序功能的体现</li>
<li>通过<strong>多次执行</strong>，<strong>一个程序可对应多个进程</strong>；通过调用关系，<strong>一个进程可包括多个程序</strong></li>
</ul>
<blockquote>
<p> 程序是菜谱，进程是做菜</p>
</blockquote>
<p><strong>进程与程序的区别？</strong></p>
<ul>
<li>进程是<strong>动态</strong>的，程序是<strong>静态</strong>的；程序是有序代码的集合，进程是程序的执行，进程有核心态/用户态</li>
<li>进程是暂时的，程序是永久的；进程是一个状态变化的过程，程序可长久保存</li>
<li>进程与程序的组成不同：进程组成包括程序、数据和进程控制块（即进程状态信息）</li>
</ul>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210323133306236.png" alt="image-20210323133306236" style="zoom:50%;">

<blockquote>
<p>体现了进程的动态切换特性</p>
</blockquote>
<h3 id="3-进程的特点"><a href="#3-进程的特点" class="headerlink" title="3. 进程的特点"></a>3. 进程的特点</h3><ul>
<li>动态性：动态创建、结束进程</li>
<li>并发性：可以被独立调度并占用处理机运行：<strong>并发运行</strong></li>
<li>独立性：不同进程的工作不相互影响</li>
<li>制约性：因访问共享数据/资源或进程同步而产生制约</li>
</ul>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210323133620864.png" alt="image-20210323133620864" style="zoom:50%;">

<blockquote>
<p>a)动态性 b)相对独立性 c)调度策略–流水线</p>
</blockquote>
<p>描述进程的数据结构：进程控制块<strong>「PCB, Process Control Block」</strong></p>
<h3 id="4-进程控制结构"><a href="#4-进程控制结构" class="headerlink" title="4. 进程控制结构"></a>4. 进程控制结构</h3><p><strong>进程控制块：</strong> 操作系统管理控制进程运行所用的信息集合，操作系统用PCB来描述进程的基本情况以及运行变化的过程</p>
<p>PCB是进程存在的唯一标志，为对进程的唯一描述</p>
<p><strong>使用PCB</strong></p>
<ul>
<li><strong>进程的创建：</strong> 为该进程生成一个PCB</li>
<li><strong>进程的终止：</strong> 回收它的PCB</li>
<li><strong>进程的组织管理：</strong> 通过对PCB的组织管理来实现</li>
</ul>
<p><strong>PCB的三大信息</strong></p>
<ol>
<li><p><strong>进程标识信息：</strong> 如本进程的标识，本进程的产生者标识（父进程标识）；用户标识</p>
</li>
<li><p><strong>处理机状态信息保存区。</strong> 保存进程的运行现场信息：</p>
<ul>
<li><strong>用户可见寄存器：</strong> 用户程序可以使用的<strong>数据，地址等寄存器</strong></li>
<li><strong>控制和状态寄存器：</strong> 如程序计数器（PC），程序状态字（PSW）</li>
<li><strong>栈指针：</strong> 过程调用/系统调用/中断处理和返回时需要用到它</li>
</ul>
</li>
<li><p><strong>进程控制信息</strong></p>
<ul>
<li><strong>调度和状态信息：</strong> 用于调度进程并占用处理机使用</li>
<li><strong>进程间通信信息：</strong> 来支持进程间的与通信相关的各种标识、信号、信件等，这些信息存在接收方的PCB中</li>
<li><strong>存储管理信息：</strong> 包含有指向本进程印象存储空间的数据结构</li>
<li><strong>进程所用资源：</strong> 说明由进程打开，使用的系统资源，如打开的文件等</li>
<li><strong>有关数据结构连接信息：</strong> 进程可以连接到一个进程队列中，或<strong>连接到相关的其他进程的PCB</strong></li>
</ul>
</li>
</ol>
<p><strong>PCB的组织方式</strong></p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210323193928336.png" alt="image-20210323193928336" style="zoom:50%;">

<h2 id="7-2-进程状态「State」"><a href="#7-2-进程状态「State」" class="headerlink" title="7.2 进程状态「State」"></a>7.2 进程状态「State」</h2><h3 id="7-2-1-进程的生命期管理"><a href="#7-2-1-进程的生命期管理" class="headerlink" title="7.2.1 进程的生命期管理"></a>7.2.1 进程的生命期管理</h3><p>$$<br>创建\rightarrow 运行\rightarrow 等待\rightarrow 唤醒\rightarrow 结束<br>$$</p>
<h4 id="lt-1-gt-创建"><a href="#lt-1-gt-创建" class="headerlink" title="&lt;1&gt; 创建"></a>&lt;1&gt; 创建</h4><p>引起进程创建的3个主要事件：</p>
<ul>
<li>系统初始化时；</li>
<li>用户请求创建一个新进程；</li>
<li>正在运行的进程执行了创建进程的系统调用</li>
</ul>
<h4 id="lt-2-gt-运行"><a href="#lt-2-gt-运行" class="headerlink" title="&lt;2&gt; 运行"></a>&lt;2&gt; 运行</h4><p>内核选择一个就绪的进程，让它占用处理机并执行</p>
<h4 id="lt-3-gt-等待"><a href="#lt-3-gt-等待" class="headerlink" title="&lt;3&gt; 等待"></a>&lt;3&gt; 等待</h4><p>以下情况，进程等待（阻塞）：</p>
<ol>
<li>请求并等待系统服务</li>
<li>启动某种操作，无法马上完成</li>
<li>需要的数据没有到达</li>
</ol>
<p>进程只能自己阻塞自己，因为只有进程自身才知道何时需要等待某种事件的发生</p>
<h4 id="lt-4-gt-唤醒"><a href="#lt-4-gt-唤醒" class="headerlink" title="&lt;4&gt; 唤醒"></a>&lt;4&gt; 唤醒</h4><blockquote>
<p>被动状况：$waiting\rightarrow running$</p>
</blockquote>
<ol>
<li>被阻塞进程需要的资源可被满足</li>
<li>被阻塞进程等待的事件到达</li>
<li>将该进程的PCB插入到就绪队列</li>
</ol>
<blockquote>
<p>进程只能被别的进程或操作系统唤醒</p>
</blockquote>
<h4 id="lt-5-gt-结束"><a href="#lt-5-gt-结束" class="headerlink" title="&lt;5&gt; 结束"></a>&lt;5&gt; 结束</h4><ul>
<li>正常退出【自愿】</li>
<li>错误退出【自愿】</li>
<li>致命错误【强制】</li>
<li>被其他进程杀死【强制】</li>
</ul>
<h3 id="7-2-2-进程状态变化模型"><a href="#7-2-2-进程状态变化模型" class="headerlink" title="7.2.2 进程状态变化模型"></a>7.2.2 进程状态变化模型</h3><p><strong>进程的三种基本状态：</strong></p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210323195056829.png" alt="image-20210323195056829" style="zoom:50%;">

<p><strong>状态变化图：</strong></p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210323195135244.png" alt="image-20210323195135244" style="zoom:50%;">

<blockquote>
<p>Ready为就绪状态的进程</p>
</blockquote>
<h3 id="7-2-3-进程挂起"><a href="#7-2-3-进程挂起" class="headerlink" title="7.2.3 进程挂起"></a>7.2.3 进程挂起</h3><blockquote>
<p>来合理充分地利用系统资源</p>
</blockquote>
<p>进程在挂起状态时，意味着进程没有占用内存空间，处在挂起状态的进程映像在磁盘上</p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210323195630177.png" alt="image-20210323195630177" style="zoom:50%;">

<p><strong>挂起状态：</strong></p>
<ul>
<li><p><strong>阻塞挂起状态（Blocked suspend）：</strong> 进程在外存并等待某事件的出现</p>
</li>
<li><p><strong>就绪挂起状态（Ready suspend）：</strong> 进程在外存，但只要进入内存，即可运行</p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210323195852296.png" alt="image-20210323195852296" style="zoom:50%;">

</li>
</ul>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210323200052014.png" alt="image-20210323200052014" style="zoom:50%;">

<p><font color="red"><strong>OS怎么通过PCB和定义的进程状态来管理PCB，帮助完成进程的调度过程？</strong></font></p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210323201256038.png" alt="image-20210323201256038" style="zoom:50%;">

<p><strong>状态队列：</strong></p>
<ul>
<li>由os来维护<strong>一组队列</strong>，用来表示系统当中所有进程的当前状态</li>
<li>不同的状态分别用不同的队列来表示（就绪队列、各种类型的阻塞队列）</li>
<li>每个<strong>进程的PCB都根据他的状态</strong>加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列</li>
</ul>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210323202002300.png" alt="image-20210323202002300" style="zoom:50%;">

<blockquote>
<p>多个就绪队列体现了优先级</p>
</blockquote>
<h2 id="7-3-线程「Thread」"><a href="#7-3-线程「Thread」" class="headerlink" title="7.3 线程「Thread」"></a>7.3 线程「Thread」</h2><h3 id="7-3-1-线程-amp-进程"><a href="#7-3-1-线程-amp-进程" class="headerlink" title="7.3.1 线程 &amp; 进程"></a>7.3.1 线程 &amp; 进程</h3><img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210323202504735.png" alt="image-20210323202504735" style="zoom:50%;">
$$
Thread = Process- Shared \ Sources
$$
**线程优点：**

<ul>
<li>一个进程中可以同时存在多个线程</li>
<li>各个线程之间可以并发执行</li>
<li>各个线程之间可以共享地址空间和文件等资源</li>
</ul>
<p><strong>线程缺点：</strong></p>
<ul>
<li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li>
</ul>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210323203250042.png" alt="image-20210323203250042" style="zoom:50%;">

<p><strong>线程与进程的比较</strong></p>
<ul>
<li>进程是资源分配单位，线程是CPU调度单位</li>
<li>进程拥有一个完整的资源平台，<strong>但是线程只独享必不可少的资源</strong>，如寄存器和栈</li>
<li>线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系</li>
<li>线程能减少并发执行的时间和空间开销<strong>【进程切换进行的页表开销十分大】</strong><ul>
<li>线程的创建时间比进程短</li>
<li>线程的终止时间比进程短</li>
<li>同一进程内的线程切换时间比进程短</li>
<li>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信</li>
</ul>
</li>
</ul>
<h3 id="7-3-2-线程的实现"><a href="#7-3-2-线程的实现" class="headerlink" title="7.3.2 线程的实现"></a>7.3.2 线程的实现</h3><p><strong>用户线程：</strong> 在用户空间实现【os看不见】</p>
<p><strong>内核线程：</strong> 在内核中实现【由os管理】</p>
<p><strong>轻量级进程：</strong> 在内核中实现，支持用户线程</p>
<h4 id="lt-1-gt-用户线程与内核线程的对应关系"><a href="#lt-1-gt-用户线程与内核线程的对应关系" class="headerlink" title="&lt;1&gt; 用户线程与内核线程的对应关系"></a>&lt;1&gt; 用户线程与内核线程的对应关系</h4><blockquote>
<p>有多对一，一对一，多对多。此刻举例为多对多：</p>
</blockquote>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210323204300913.png" alt="image-20210323204300913" style="zoom:50%;">

<h4 id="lt-1-gt-用户线程"><a href="#lt-1-gt-用户线程" class="headerlink" title="&lt;1&gt; 用户线程"></a>&lt;1&gt; <strong>用户线程</strong></h4><img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210323205454265.png" alt="image-20210323205454265" style="zoom:50%;">

<p>在用户空间实现的线程机制，它<strong>不依赖于os的内核</strong>，而是由一组<strong>用户级的线程库的函数</strong>来完成线程的管理，包括进程的创建、终止、同步和调度等</p>
<ul>
<li>因为用户线程的维护由相应进程来完成（通过线程库函数），不需要os内核了解用户线程的存在，可以用于不支持线程技术的多进程的os</li>
<li>每个进程都需要它自己私有的<strong>线程控制块【TCB】</strong>列表，用来跟踪记录它各个线程的状态信息（PC、栈指针、寄存器），<strong>TCB由线程库函数来维护</strong></li>
<li>用户线程的切换也是由线程库函数来完成，不需要用户态/核心态切换，所以速度特别快</li>
<li>允许<strong>每个进程拥有自定义的线程调度算法</strong></li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>如果一个线程发起系统调用而阻塞，则整个线程在等待</li>
<li>因为当一个线程开始运行后，除非它<strong>主动交出CPU的使用权</strong>，否则他所在的进程当中的其他线程将无法运行</li>
<li>由于时间片分配给进程，因此与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢</li>
</ul>
<h4 id="lt-2-gt-内核线程"><a href="#lt-2-gt-内核线程" class="headerlink" title="&lt;2&gt; 内核线程"></a>&lt;2&gt; <strong>内核线程</strong></h4><p>指在<strong>os的内核</strong>当中实现的一种线程机制，由os的内核来完成线程的创建、终止和管理</p>
<ul>
<li>在支持内核线程的os中，由内核来维护进程和线程的上下文信息（PCB和TCB）</li>
<li>线程的创建、终止和切换都是通过系统调用/内核函数的方式来运行，由内核来完成。<strong>因此系统开销较大</strong></li>
<li>在一个进程当中，如果<strong>某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行</strong></li>
<li>时间片分配给线程，<strong>多线程的进程获得更多CPU时间</strong></li>
<li>Windows NT和Windows 2000/XP支持内核线程</li>
</ul>
<h4 id="lt-3-gt-轻量级进程「Lightweight-Process」"><a href="#lt-3-gt-轻量级进程「Lightweight-Process」" class="headerlink" title="&lt;3&gt; 轻量级进程「Lightweight Process」"></a>&lt;3&gt; 轻量级进程「Lightweight Process」</h4><blockquote>
<p>又称<strong>【协程】</strong></p>
</blockquote>
<h2 id="7-4-进程间通信「Inter-Process-Communication」"><a href="#7-4-进程间通信「Inter-Process-Communication」" class="headerlink" title="7.4 进程间通信「Inter-Process Communication」"></a>7.4 进程间通信「Inter-Process Communication」</h2><h3 id="7-4-1-上下文切换"><a href="#7-4-1-上下文切换" class="headerlink" title="7.4.1 上下文切换"></a>7.4.1 上下文切换</h3><p>停止当前运行进程并且调度其他进程</p>
<ul>
<li>必须在切换之前存储许多部分的进程上下文</li>
<li>必须能够在之后回复他们，所以进程不能显示它曾经被暂停过</li>
<li>必须快速（上下文转换时非常频繁）</li>
</ul>
<p><strong>需要存储什么上下文？</strong></p>
<ul>
<li>寄存器（PC、SP，…）,CPU状态，…</li>
<li>一些时候会比较费时，应当尽可能避免</li>
</ul>
<p>希望上下文开销越小越好</p>
<ul>
<li>操作系统为活跃进程准备了PCB</li>
<li>操作系统将PCB放置在一个合适的队列里</li>
</ul>
<h3 id="7-4-2-创建和执行进程"><a href="#7-4-2-创建和执行进程" class="headerlink" title="7.4.2 创建和执行进程"></a>7.4.2 创建和执行进程</h3><ul>
<li>用<code>fork</code>和<code>exec</code>创建进程的示例</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int pid = fork();	//创建子进程</span><br><span class="line"><span class="keyword">if</span>(pid == 0)&#123;			//子进程在这里继续</span><br><span class="line">	<span class="built_in">exec</span>(<span class="string">&quot;program&quot;</span>, argc, argv0, argv1, ...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>fork()</code>创建一个继承的子进程</p>
<ul>
<li>复制父进程的所有变量和内存</li>
<li>复制父进程的所有CPU寄存器【有一个寄存器例外】</li>
</ul>
</li>
<li><p><code>fork()</code>的返回值</p>
<ul>
<li><p>子进程的<code>fork()</code>返回0</p>
</li>
<li><p>父进程的<code>fork()</code>返回子进程标识符</p>
</li>
<li><p><code>fork()</code>返回值方便后续使用，子进程可以使用<code>getpid()</code>获取<strong>PID</strong></p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324085405144.png" alt="image-20210324085405144" style="zoom:50%;">

</li>
</ul>
</li>
</ul>
<p><strong>系统调用exec（）加载程序取代当前运行的进程</strong></p>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324092555412.png" alt="image-20210324092555412" style="zoom:50%;">

<p><strong><code>exec()</code>的作用</strong></p>
<ul>
<li>exec()调用允许一个进程“加载”一个不同的程序并且在main开始执行（事实上_start）</li>
<li>它允许一个进程指定参数的数量（argc）和它字符串参数数组（argv）</li>
<li>子进程fork()后exec()时会将<code>stack()&amp;heap()</code>重写</li>
</ul>
<p><strong>fork()的简单实现</strong></p>
<ul>
<li>分配内存给子进程</li>
<li>复制父进程的内存和CPU寄存器到子进程中</li>
<li><strong>开销非常大！</strong></li>
</ul>
<p><strong>99%情况中，在调用fork()之后调用exec()</strong></p>
<ul>
<li>但是fork()操作中<strong>内存复制</strong>是没有作用的</li>
<li>子进程可能关闭打开的文件和链接</li>
<li>开销因此是高的</li>
</ul>
<p><strong>改进：vfork</strong></p>
<ul>
<li>一个创建进程的系统调用，不需要创建一个同样的内存映像</li>
<li>一些时候被称为轻量级fork()</li>
<li>子进程几乎立即调用fork（）</li>
<li>现在不再使用vfork()，而是改进使用COW【Copy on Write】<strong>「读时共享 写时复制」</strong>只复制了元数据【页表】</li>
</ul>
<h3 id="7-4-4-等待和终止进程"><a href="#7-4-4-等待和终止进程" class="headerlink" title="7.4.4 等待和终止进程"></a>7.4.4 等待和终止进程</h3><p>Wait()系统调用是被父进程用来等待子进程的结束</p>
<ul>
<li>子进程向父进程返回一个值，父进程必须接受这个值并处理</li>
<li>wait()系统调用担任这个要求</li>
</ul>
<p>父进程配合子进程的exit()后回收所有子进程的资源，最初的进程<strong>【根进程】</strong>结束后直接关机</p>
<ol>
<li>进程结束执行后，调用exit()</li>
<li>这个系统调用：<ul>
<li>将程序的“结果”作为一个参数，关闭所有打开的文件、链接等</li>
<li>释放内存，释放大部分支持进程的os结构</li>
<li>检查父进程是否存活<ul>
<li>如果存活，<strong>保留结果的值直到父进程需要它</strong>；在这种情况里，进程没有真正死亡，但是进入了僵尸状态（zombie/defunct）</li>
<li>如果没有，释放所有的数据结构，这个进程死亡</li>
</ul>
</li>
<li>进程终止是最终的垃圾收集【资源回收】</li>
</ul>
</li>
</ol>
<img src="/Users/zoriswang/Library/Application Support/typora-user-images/image-20210324094738784.png" alt="image-20210324094738784" style="zoom:50%;">

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> Zoris Wang
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Yitee"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2021/03/16/About%20Me">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://i.loli.net/2020/10/30/GFDWywm9ProCXcR.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://i.loli.net/2020/10/30/urJAkYB276w5gvD.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=1332662900&auto=0&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>